{
"version":3,
"file":"module$node_modules$bitcoinjs_lib$src$templates$witnessscripthash$input.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,wEAAA,CAA4F,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,OAAhB,CAAwBC,MAAxB,CAA+BC,OAA/B,CAAuCC,YAAvC,CAAqD,CAWzJC,QAASA,MAAM,CAACC,MAAD,CAASC,eAAT,CAA0B,CACvCC,SAAA,CAAUC,KAAAC,MAAV,CAAuBJ,MAAvB,CACA,IAAoB,CAApB,CAAIA,MAAAK,OAAJ,CAAuB,MAAO,CAAA,CAE9B,KAAMC,cAAgBN,MAAA,CAAOA,MAAAK,OAAP,CAAuB,CAAvB,CACtB,IAAI,CAACE,mBAAAC,SAAA,CAAgBF,aAAhB,CAAL,CAAqC,MAAO,CAAA,CAEtCG,cAAAA,CAAsBC,OAAAC,UAAA,CAAkBL,aAAlB,CAG5B,IAAI,CAACG,aAAL,EAA2D,CAA3D,GAA4BA,aAAAJ,OAA5B,CAA8D,MAAO,CAAA,CAE/DO,OAAAA,CAAsBF,OAAAG,QAAA,CAAgBb,MAAAc,MAAA,CAAa,CAAb,CAAiB,EAAjB,CAAhB,CAS5B,OANIC,MAAAC,MAAAjB,MAAA,CAAkBa,MAAlB,CAMJ;AALEG,KAAAE,OAAAlB,MAAA,CAAmBU,aAAnB,CAKF,EAHIS,IAAAF,MAAAjB,MAAA,CAAiBa,MAAjB,CAAsCX,eAAtC,CAGJ,EAFEiB,IAAAD,OAAAlB,MAAA,CAAkBU,aAAlB,CAEF,EAAIU,IAAAH,MAAAjB,MAAA,CAAiBa,MAAjB,CAAJ,EACEO,IAAAF,OAAAlB,MAAA,CAAkBU,aAAlB,CADF,CACiD,CAAA,CADjD,CAGO,CAAA,CAxBgC,CARzC,IAAMC,QAAUf,OAAA,CAAQ,8CAAR,CAAhB,CACMQ,MAAQR,OAAA,CAAQ,6CAAR,CADd,CAEMO,UAAYP,OAAA,CAAQ,qCAAR,CAFlB,CAIMuB,KAAOvB,OAAA,CAAQ,gEAAR,CAJb,CAKMwB,KAAOxB,OAAA,CAAQ,8DAAR,CALb;AAMMoB,MAAQpB,OAAA,CAAQ,kEAAR,CA4BdI,MAAAqB,OAAA,CAAeC,QAAS,EAAG,CAAE,MAAO,yBAAT,CAE3BzB,OAAAC,QAAA,CAAiB,CAAEE,MAAAA,KAAF,CAvCwI;",
"sources":["node_modules/bitcoinjs-lib/src/templates/witnessscripthash/input.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$bitcoinjs_lib$src$templates$witnessscripthash$input\"] = function(global,process,require,module,exports,shadow$shims) {\n// <scriptSig> {serialized scriptPubKey script}\n\nconst bscript = require('../../script')\nconst types = require('../../types')\nconst typeforce = require('typeforce')\n\nconst p2ms = require('../multisig/')\nconst p2pk = require('../pubkey/')\nconst p2pkh = require('../pubkeyhash/')\n\nfunction check (chunks, allowIncomplete) {\n  typeforce(types.Array, chunks)\n  if (chunks.length < 1) return false\n\n  const witnessScript = chunks[chunks.length - 1]\n  if (!Buffer.isBuffer(witnessScript)) return false\n\n  const witnessScriptChunks = bscript.decompile(witnessScript)\n\n  // is witnessScript a valid script?\n  if (!witnessScriptChunks || witnessScriptChunks.length === 0) return false\n\n  const witnessRawScriptSig = bscript.compile(chunks.slice(0, -1))\n\n  // match types\n  if (p2pkh.input.check(witnessRawScriptSig) &&\n    p2pkh.output.check(witnessScriptChunks)) return true\n\n  if (p2ms.input.check(witnessRawScriptSig, allowIncomplete) &&\n    p2ms.output.check(witnessScriptChunks)) return true\n\n  if (p2pk.input.check(witnessRawScriptSig) &&\n    p2pk.output.check(witnessScriptChunks)) return true\n\n  return false\n}\ncheck.toJSON = function () { return 'witnessScriptHash input' }\n\nmodule.exports = { check }\n\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","check","chunks","allowIncomplete","typeforce","types","Array","length","witnessScript","Buffer","isBuffer","witnessScriptChunks","bscript","decompile","witnessRawScriptSig","compile","slice","p2pkh","input","output","p2ms","p2pk","toJSON","check.toJSON"]
}
