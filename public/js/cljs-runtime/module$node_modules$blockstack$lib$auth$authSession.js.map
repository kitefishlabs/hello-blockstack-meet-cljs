{
"version":3,
"file":"module$node_modules$blockstack$lib$auth$authSession.js",
"lineCount":6,
"mappings":"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",
"sources":["node_modules/blockstack/lib/auth/authSession.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$blockstack$lib$auth$authSession\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeCoreSessionRequest = makeCoreSessionRequest;\nexports.sendCoreSessionRequest = sendCoreSessionRequest;\nexports.getCoreSession = getCoreSession;\n\nvar _jsontokens = require('jsontokens');\n\nrequire('cross-fetch/polyfill');\n\n/**\n * Create an authentication token to be sent to the Core API server\n * in order to generate a Core session JWT.\n *\n * @param {String} appDomain  The unique application identifier (e.g. foo.app, www.foo.com, etc).\n * @param {Array} appMethods  The list of API methods this application will need.\n * @param {String} appPrivateKey  The application-specific private key\n * @param {String|null} blockchainID  This is the blockchain ID of the requester\n * @param {String} thisDevice Identifier of the current device\n *\n * @return {String} a JWT signed by the app's private key\n * @deprecated\n * @private\n */\nfunction makeCoreSessionRequest(appDomain, appMethods, appPrivateKey) {\n  var blockchainID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var thisDevice = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n  if (thisDevice === null) {\n    thisDevice = '.default';\n  }\n\n  var appPublicKey = _jsontokens.SECP256K1Client.derivePublicKey(appPrivateKey);\n  var appPublicKeys = [{\n    public_key: appPublicKey,\n    device_id: thisDevice\n  }];\n\n  var authBody = {\n    version: 1,\n    blockchain_id: blockchainID,\n    app_private_key: appPrivateKey,\n    app_domain: appDomain,\n    methods: appMethods,\n    app_public_keys: appPublicKeys,\n    device_id: thisDevice\n\n    // make token\n  };var tokenSigner = new _jsontokens.TokenSigner('ES256k', appPrivateKey);\n  var token = tokenSigner.sign(authBody);\n\n  return token;\n}\n\n/**\n * Send Core a request for a session token.\n *\n * @param {String} coreHost host name of the core node\n * @param {Number} corePort port number of the core node\n * @param {String} coreAuthRequest  a signed JWT encoding the authentication request\n * @param {String} apiPassword the API password for Core\n *\n * @return {Promise} the resolves to a JWT signed with the Core API server's private key\n * that authorizes the bearer to carry out the requested operations and rejects\n * with an error message otherwise\n * @deprecated\n * @private\n */\nfunction sendCoreSessionRequest(coreHost, corePort, coreAuthRequest, apiPassword) {\n  return new Promise(function (resolve, reject) {\n    if (!apiPassword) {\n      reject('Missing API password');\n      return null;\n    }\n\n    var options = {\n      headers: {\n        Authorization: 'bearer ' + apiPassword\n      }\n    };\n\n    var url = 'http://' + coreHost + ':' + corePort + '/v1/auth?authRequest=' + coreAuthRequest;\n\n    return fetch(url, options).then(function (response) {\n      if (!response.ok) {\n        reject('HTTP status not OK');\n        throw new Error('HTTP status not OK');\n      }\n      return response.text();\n    }).then(function (responseText) {\n      return JSON.parse(responseText);\n    }).then(function (responseJson) {\n      var token = responseJson.token;\n      if (!token) {\n        reject('Failed to get Core session token');\n        return null;\n      }\n      resolve(token);\n      return token;\n    }).catch(function (error) {\n      console.error(error);\n      reject('Invalid Core response: not JSON');\n    });\n  });\n}\n\n/**\n * Get a core session token.  Generate an auth request, sign it, send it to Core,\n * and get back a session token.\n *\n * @param {String} coreHost Core API server's hostname\n * @param {Number} corePort Core API server's port number\n * @param {String} apiPassword core api password\n * @param  {String} appPrivateKey Application's private key\n * @param  {String} blockchainId blockchain ID of the user signing in.\n * `null` if user has no blockchain ID\n * @param {String} authRequest authentication request token\n * @param {String} deviceId identifier for the current device\n *\n * @return {Promise} a Promise that resolves to a Core session token or rejects\n * with an error message.\n * @deprecated\n * @private\n */\nfunction getCoreSession(coreHost, corePort, apiPassword, appPrivateKey) {\n  var blockchainId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var authRequest = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var deviceId = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : '0';\n\n  if (!authRequest) {\n    return Promise.reject('No authRequest provided');\n  }\n\n  var payload = null;\n  var authRequestObject = null;\n  try {\n    authRequestObject = (0, _jsontokens.decodeToken)(authRequest);\n    if (!authRequestObject) {\n      return Promise.reject('Invalid authRequest in URL query string');\n    }\n    if (!authRequestObject.payload) {\n      return Promise.reject('Invalid authRequest in URL query string');\n    }\n    payload = authRequestObject.payload;\n  } catch (e) {\n    console.error(e.stack);\n    return Promise.reject('Failed to parse authRequest in URL');\n  }\n\n  var appDomain = payload.domain_name;\n  if (!appDomain) {\n    return Promise.reject('No domain_name in authRequest');\n  }\n  var appMethods = payload.scopes;\n\n  var coreAuthRequest = makeCoreSessionRequest(appDomain, appMethods, appPrivateKey, blockchainId, deviceId);\n\n  return sendCoreSessionRequest(coreHost, corePort, coreAuthRequest, apiPassword);\n}\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","makeCoreSessionRequest","appDomain","appMethods","appPrivateKey","blockchainID","arguments","length","undefined","thisDevice","appPublicKeys","public_key","_jsontokens","SECP256K1Client","derivePublicKey","appPublicKey","device_id","authBody","version","blockchain_id","app_private_key","app_domain","methods","app_public_keys","sign","tokenSigner","TokenSigner","token","sendCoreSessionRequest","coreHost","corePort","coreAuthRequest","apiPassword","Promise","resolve","reject","fetch","options","headers","Authorization","then","response","ok","Error","text","responseText","JSON","parse","responseJson","catch","error","console","Object","defineProperty","value","getCoreSession","blockchainId","authRequest","deviceId","payload","authRequestObject","decodeToken","e","stack","domain_name","scopes"]
}
