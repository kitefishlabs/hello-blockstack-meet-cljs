shadow$provide.module$node_modules$blockstack$lib$operations$skeletons=function(global,process,require,module,exports,shadow$shims){function asAmountV2(amount){return"number"===typeof amount?{units:"BTC",amount:_bigi2.default.fromByteArrayUnsigned(String(amount))}:{units:amount.units,amount:amount.amount}}function makeTXbuilder(){var txb=new _bitcoinjsLib2.default.TransactionBuilder(_config.config.network.layer1);txb.setVersion(1);return txb}function opEncode(opcode){opcode=""+_config.config.network.MAGIC_BYTES+
opcode;if(3!==opcode.length)throw Error("Runtime error: invalid MAGIC_BYTES");return opcode}function makeRegisterSkeleton(fullyQualifiedName,ownerAddress){var valueHash=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,burnTokenAmountHex=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;burnTokenAmountHex&&!valueHash&&(valueHash="0000000000000000000000000000000000000000");if(valueHash){if(40!==valueHash.length)throw Error("Value hash length incorrect. Expecting 20-bytes, hex-encoded");
if(burnTokenAmountHex&&16!==burnTokenAmountHex.length)throw Error("Burn field length incorrect.  Expecting 8-bytes, hex-encoded");var payload=shadow$shims.Buffer.alloc(burnTokenAmountHex?65:57,0);payload.write(fullyQualifiedName,0,37,"ascii");payload.write(valueHash,37,20,"hex");burnTokenAmountHex&&payload.write(burnTokenAmountHex,57,8,"hex")}else payload=shadow$shims.Buffer.from(fullyQualifiedName,"ascii");valueHash=shadow$shims.Buffer.concat([shadow$shims.Buffer.from(opEncode(":"),"ascii"),payload]);
valueHash=_bitcoinjsLib2.default.payments.embed({data:[valueHash]}).output;burnTokenAmountHex=makeTXbuilder();burnTokenAmountHex.addOutput(valueHash,0);burnTokenAmountHex.addOutput(ownerAddress,_utils.DUST_MINIMUM);return burnTokenAmountHex.buildIncomplete()}Object.defineProperty(exports,"__esModule",{value:!0});exports.BlockstackNamespace=void 0;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||
!1;descriptor.configurable=!0;"value"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){protoProps&&defineProperties(Constructor.prototype,protoProps);staticProps&&defineProperties(Constructor,staticProps);return Constructor}}();exports.makePreorderSkeleton=function(fullyQualifiedName,consensusHash,preorderAddress,burnAddress,burn){var registerAddress=5<arguments.length&&void 0!==arguments[5]?arguments[5]:
null,burnAmount=asAmountV2(burn),network=_config.config.network,nameBuff=shadow$shims.Buffer.from((0,_utils.decodeB40)(fullyQualifiedName),"hex");network=_bitcoinjsLib2.default.address.toOutputScript(preorderAddress,network.layer1);nameBuff=[nameBuff,network];registerAddress&&(registerAddress=shadow$shims.Buffer.from(registerAddress,"ascii"),nameBuff.push(registerAddress));registerAddress=shadow$shims.Buffer.concat(nameBuff);nameBuff=(0,_utils.hash160)(registerAddress);registerAddress=shadow$shims.Buffer.alloc("BTC"===
burnAmount.units?39:66);registerAddress.write(opEncode("?"),0,3,"ascii");nameBuff.copy(registerAddress,3);registerAddress.write(consensusHash,23,16,"hex");if("BTC"!==burnAmount.units){nameBuff=burnAmount.amount.toHex();if(16<nameBuff.length)throw Error("Cannot preorder '"+fullyQualifiedName+"': cannot fit price into 8 bytes");nameBuff=("0000000000000000"+nameBuff).slice(-16);registerAddress.write(nameBuff,39,8,"hex");registerAddress.write(burnAmount.units,47,burnAmount.units.length,"ascii")}nameBuff=
_bitcoinjsLib2.default.payments.embed({data:[registerAddress]}).output;registerAddress=makeTXbuilder();registerAddress.addOutput(nameBuff,0);registerAddress.addOutput(preorderAddress,_utils.DUST_MINIMUM);"BTC"===burnAmount.units?(burnAmount=parseInt(burnAmount.amount.toHex(),16),registerAddress.addOutput(burnAddress,burnAmount)):registerAddress.addOutput(burnAddress,_utils.DUST_MINIMUM);return registerAddress.buildIncomplete()};exports.makeRegisterSkeleton=makeRegisterSkeleton;exports.makeRenewalSkeleton=
function(fullyQualifiedName,nextOwnerAddress,lastOwnerAddress,burnAddress,burn){var valueHash=5<arguments.length&&void 0!==arguments[5]?arguments[5]:null,burnAmount=asAmountV2(burn),network=_config.config.network,burnTokenAmount="BTC"===burnAmount.units?null:burnAmount.amount;burnAmount="BTC"===burnAmount.units?parseInt(burnAmount.amount.toHex(),16):_utils.DUST_MINIMUM;var burnTokenHex=null;if(burnTokenAmount){burnTokenAmount=burnTokenAmount.toHex();if(16<burnTokenAmount.length)throw Error("Cannot renew '"+
fullyQualifiedName+"': cannot fit price into 8 bytes");burnTokenHex=("0000000000000000"+burnTokenAmount).slice(-16)}valueHash=makeRegisterSkeleton(fullyQualifiedName,nextOwnerAddress,valueHash,burnTokenHex);network=_bitcoinjsLib2.default.TransactionBuilder.fromTransaction(valueHash,network.layer1);network.addOutput(lastOwnerAddress,_utils.DUST_MINIMUM);network.addOutput(burnAddress,burnAmount);return network.buildIncomplete()};exports.makeTransferSkeleton=function(fullyQualifiedName,consensusHash,
newOwner){var keepZonefile=3<arguments.length&&void 0!==arguments[3]?arguments[3]:!1,opRet=shadow$shims.Buffer.alloc(36),keepChar="~";keepZonefile&&(keepChar="\x3e");opRet.write(opEncode("\x3e"),0,3,"ascii");opRet.write(keepChar,3,1,"ascii");(0,_utils.hash128)(shadow$shims.Buffer.from(fullyQualifiedName,"ascii")).copy(opRet,4);opRet.write(consensusHash,20,16,"hex");keepZonefile=_bitcoinjsLib2.default.payments.embed({data:[opRet]}).output;opRet=makeTXbuilder();opRet.addOutput(keepZonefile,0);opRet.addOutput(newOwner,
_utils.DUST_MINIMUM);return opRet.buildIncomplete()};exports.makeUpdateSkeleton=function(fullyQualifiedName,consensusHash,valueHash){var opRet=shadow$shims.Buffer.alloc(39);fullyQualifiedName=shadow$shims.Buffer.from(fullyQualifiedName,"ascii");consensusHash=shadow$shims.Buffer.from(consensusHash,"ascii");consensusHash=(0,_utils.hash128)(shadow$shims.Buffer.concat([fullyQualifiedName,consensusHash]));opRet.write(opEncode("+"),0,3,"ascii");consensusHash.copy(opRet,3);opRet.write(valueHash,19,20,"hex");
valueHash=_bitcoinjsLib2.default.payments.embed({data:[opRet]}).output;opRet=makeTXbuilder();opRet.addOutput(valueHash,0);return opRet.buildIncomplete()};exports.makeRevokeSkeleton=function(fullyQualifiedName){var opRet=shadow$shims.Buffer.alloc(3);fullyQualifiedName=shadow$shims.Buffer.from(fullyQualifiedName,"ascii");opRet.write(opEncode("~"),0,3,"ascii");opRet=shadow$shims.Buffer.concat([opRet,fullyQualifiedName]);opRet=_bitcoinjsLib2.default.payments.embed({data:[opRet]}).output;fullyQualifiedName=
makeTXbuilder();fullyQualifiedName.addOutput(opRet,0);return fullyQualifiedName.buildIncomplete()};exports.makeNamespacePreorderSkeleton=function(namespaceID,consensusHash,preorderAddress,registerAddress,burn){var burnAmount=asAmountV2(burn);if("BTC"!==burnAmount.units&&"STACKS"!==burnAmount.units)throw Error("Invalid burnUnits "+burnAmount.units);var network=_config.config.network;burn=network.getDefaultBurnAddress();namespaceID=shadow$shims.Buffer.from((0,_utils.decodeB40)(namespaceID),"hex");network=
_bitcoinjsLib2.default.address.toOutputScript(preorderAddress,network.layer1);registerAddress=shadow$shims.Buffer.from(registerAddress,"ascii");registerAddress=shadow$shims.Buffer.concat([namespaceID,network,registerAddress]);namespaceID=(0,_utils.hash160)(registerAddress);registerAddress=_utils.DUST_MINIMUM;network=39;"STACKS"===burnAmount.units?network=47:registerAddress=parseInt(burnAmount.amount.toHex(),16);network=shadow$shims.Buffer.alloc(network);network.write(opEncode("*"),0,3,"ascii");namespaceID.copy(network,
3);network.write(consensusHash,23,16,"hex");"STACKS"===burnAmount.units&&(consensusHash=("0000000000000000"+burnAmount.amount.toHex()).slice(-16),network.write(consensusHash,39,8,"hex"));consensusHash=_bitcoinjsLib2.default.payments.embed({data:[network]}).output;burnAmount=makeTXbuilder();burnAmount.addOutput(consensusHash,0);burnAmount.addOutput(preorderAddress,_utils.DUST_MINIMUM);burnAmount.addOutput(burn,registerAddress);return burnAmount.buildIncomplete()};exports.makeNamespaceRevealSkeleton=
function(namespace,revealAddress){namespace=namespace.toHexPayload();var opReturnBuffer=shadow$shims.Buffer.alloc(3+namespace.length/2);opReturnBuffer.write(opEncode("\x26"),0,3,"ascii");opReturnBuffer.write(namespace,3,namespace.length/2,"hex");namespace=_bitcoinjsLib2.default.payments.embed({data:[opReturnBuffer]}).output;opReturnBuffer=makeTXbuilder();opReturnBuffer.addOutput(namespace,0);opReturnBuffer.addOutput(revealAddress,_utils.DUST_MINIMUM);return opReturnBuffer.buildIncomplete()};exports.makeNamespaceReadySkeleton=
function(namespaceID){var opReturnBuffer=shadow$shims.Buffer.alloc(3+namespaceID.length+1);opReturnBuffer.write(opEncode("!"),0,3,"ascii");opReturnBuffer.write("."+namespaceID,3,namespaceID.length+1,"ascii");namespaceID=_bitcoinjsLib2.default.payments.embed({data:[opReturnBuffer]}).output;opReturnBuffer=makeTXbuilder();opReturnBuffer.addOutput(namespaceID,0);return opReturnBuffer.buildIncomplete()};exports.makeNameImportSkeleton=function(name,recipientAddr,zonefileHash){if(40!==zonefileHash.length)throw Error("Invalid zonefile hash: must be 20 bytes hex-encoded");
var network=_config.config.network,opReturnBuffer=shadow$shims.Buffer.alloc(3+name.length);opReturnBuffer.write(opEncode(";"),0,3,"ascii");opReturnBuffer.write(name,3,name.length,"ascii");name=_bitcoinjsLib2.default.payments.embed({data:[opReturnBuffer]}).output;opReturnBuffer=makeTXbuilder();zonefileHash=_bitcoinjsLib2.default.address.toBase58Check(new shadow$shims.Buffer(zonefileHash,"hex"),network.layer1.pubKeyHash);opReturnBuffer.addOutput(name,0);opReturnBuffer.addOutput(recipientAddr,_utils.DUST_MINIMUM);
opReturnBuffer.addOutput(zonefileHash,_utils.DUST_MINIMUM);return opReturnBuffer.buildIncomplete()};exports.makeAnnounceSkeleton=function(messageHash){if(40!==messageHash.length)throw Error("Invalid message hash: must be 20 bytes hex-encoded");var opReturnBuffer=shadow$shims.Buffer.alloc(3+messageHash.length/2);opReturnBuffer.write(opEncode("#"),0,3,"ascii");opReturnBuffer.write(messageHash,3,messageHash.length/2,"hex");messageHash=_bitcoinjsLib2.default.payments.embed({data:[opReturnBuffer]}).output;
opReturnBuffer=makeTXbuilder();opReturnBuffer.addOutput(messageHash,0);return opReturnBuffer.buildIncomplete()};exports.makeTokenTransferSkeleton=function(recipientAddress,consensusHash,tokenType,tokenAmount,scratchArea){if(34<scratchArea.length)throw Error("Invalid scratch area: must be no more than 34 bytes");var opReturnBuffer=shadow$shims.Buffer.alloc(46+scratchArea.length);tokenType=("00000000000000000000000000000000000000"+(new shadow$shims.Buffer(tokenType)).toString("hex")).slice(-38);var tokenValueHex=
tokenAmount.toHex();if(16<tokenValueHex.length)throw Error("Cannot send tokens: cannot fit "+tokenAmount.toString()+" into 8 bytes");tokenAmount=("0000000000000000"+tokenValueHex).slice(-16);opReturnBuffer.write(opEncode("$"),0,3,"ascii");opReturnBuffer.write(consensusHash,3,consensusHash.length/2,"hex");opReturnBuffer.write(tokenType,19,tokenType.length/2,"hex");opReturnBuffer.write(tokenAmount,38,tokenAmount.length/2,"hex");opReturnBuffer.write(scratchArea,46,scratchArea.length,"ascii");consensusHash=
_bitcoinjsLib2.default.payments.embed({data:[opReturnBuffer]}).output;scratchArea=makeTXbuilder();scratchArea.addOutput(consensusHash,0);scratchArea.addOutput(recipientAddress,_utils.DUST_MINIMUM);return scratchArea.buildIncomplete()};var _bitcoinjsLib2=(global=require("module$node_modules$bitcoinjs_lib$src$index"))&&global.__esModule?global:{default:global},_bigi2=(global=require("module$node_modules$bigi$lib$index"))&&global.__esModule?global:{default:global},_utils=require("module$node_modules$blockstack$lib$operations$utils"),
_config=require("module$node_modules$blockstack$lib$config");exports.BlockstackNamespace=function(){function BlockstackNamespace(namespaceID){if(!(this instanceof BlockstackNamespace))throw new TypeError("Cannot call a class as a function");if(19<namespaceID.length)throw Error("Namespace ID too long (19 chars max)");if(!namespaceID.match("[0123456789abcdefghijklmnopqrstuvwxyz_-]+"))throw Error("Namespace ID can only use characters 0123456789abcdefghijklmnopqrstuvwxyz-_");this.namespaceID=namespaceID;
this.base=this.coeff=this.lifetime=this.version=-1;this.buckets=[-1];this.noVowelDiscount=this.nonalphaDiscount=-1}_createClass(BlockstackNamespace,[{key:"check",value:function(){try{return this.setVersion(this.version),this.setLifetime(this.lifetime),this.setCoeff(this.coeff),this.setBase(this.base),this.setBuckets(this.buckets),this.setNonalphaDiscount(this.nonalphaDiscount),this.setNoVowelDiscount(this.noVowelDiscount),!0}catch(e){return!1}}},{key:"setVersion",value:function(version){if(0>version||
version>Math.pow(2,16)-1)throw Error("Invalid version: must be a 16-bit number");this.version=version}},{key:"setLifetime",value:function(lifetime){if(0>lifetime||lifetime>Math.pow(2,32)-1)throw Error("Invalid lifetime: must be a 32-bit number");this.lifetime=lifetime}},{key:"setCoeff",value:function(coeff){if(0>coeff||255<coeff)throw Error("Invalid coeff: must be an 8-bit number");this.coeff=coeff}},{key:"setBase",value:function(base){if(0>base||255<base)throw Error("Invalid base: must be an 8-bit number");
this.base=base}},{key:"setBuckets",value:function(buckets){if(16!==buckets.length)throw Error("Invalid buckets: must have 16 entries");for(var i=0;i<buckets.length;i++)if(0>buckets[i]||15<buckets[i])throw Error("Invalid buckets: must be 4-bit numbers");this.buckets=buckets.slice(0)}},{key:"setNonalphaDiscount",value:function(nonalphaDiscount){if(0>=nonalphaDiscount||15<nonalphaDiscount)throw Error("Invalid nonalphaDiscount: must be a positive 4-bit number");this.nonalphaDiscount=nonalphaDiscount}},
{key:"setNoVowelDiscount",value:function(noVowelDiscount){if(0>=noVowelDiscount||15<noVowelDiscount)throw Error("Invalid noVowelDiscount: must be a positive 4-bit number");this.noVowelDiscount=noVowelDiscount}},{key:"toHexPayload",value:function(){var lifeHex=("00000000"+this.lifetime.toString(16)).slice(-8),coeffHex=("00"+this.coeff.toString(16)).slice(-2),baseHex=("00"+this.base.toString(16)).slice(-2),bucketHex=this.buckets.map(function(b){return b.toString(16)}).reduce(function(b1,b2){return b1+
b2},""),discountHex=this.nonalphaDiscount.toString(16)+this.noVowelDiscount.toString(16),versionHex=("0000"+this.version.toString(16)).slice(-4),namespaceIDHex=(new shadow$shims.Buffer(this.namespaceID)).toString("hex");return lifeHex+coeffHex+baseHex+bucketHex+discountHex+versionHex+namespaceIDHex}}]);return BlockstackNamespace}()}
//# sourceMappingURL=module$node_modules$blockstack$lib$operations$skeletons.js.map
