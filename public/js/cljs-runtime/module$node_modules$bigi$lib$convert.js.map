{
"version":3,
"file":"module$node_modules$bigi$lib$convert.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,qCAAA,CAAyD,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,OAAhB,CAAwBC,MAAxB,CAA+BC,OAA/B,CAAuCC,YAAvC,CAAqD,CAEtH,IAAIC,OAASJ,OAAA,CAAQ,mCAAR,CAAb,CACIK,WAAaL,OAAA,CAAQ,mCAAR,CAQjBK,WAAAC,sBAAA,CAAmCC,QAAQ,CAACC,SAAD,CAAY,CAErD,MAAIA,UAAA,CAAU,CAAV,CAAJ,CAAmB,GAAnB,CACS,IAAIH,UAAJ,CAAe,CAAC,CAAD,CAAAI,OAAA,CAAWD,SAAX,CAAf,CADT,CAIO,IAAIH,UAAJ,CAAeG,SAAf,CAN8C,CAevDH,WAAAK,UAAAC,oBAAA,CAA2CC,QAAQ,EAAG,CACpD,IAAIJ,UAAY,IAAAK,YAAA,EAChB,OAAwB,EAAjB,GAAAL,SAAA,CAAU,CAAV,CAAA,CAAqBA,SAAAM,MAAA,CAAgB,CAAhB,CAArB,CAA0CN,SAFG,CAKtDH;UAAAU,eAAA,CAA4BC,QAAQ,CAACR,SAAD,CAAY,CAC9C,MAAO,KAAIH,UAAJ,CAAeG,SAAf,CADuC,CA2BhDH,WAAAK,UAAAO,aAAA,CAAoCZ,UAAAK,UAAAG,YAEpCR,WAAAa,WAAA,CAAwBC,QAAQ,CAACC,MAAD,CAAS,CAEvC,MAAIA,OAAA,CAAO,CAAP,CAAJ,CAAgB,GAAhB,EACMZ,MAEG,CAFSa,KAAAX,UAAAI,MAAAQ,KAAA,CAA2BF,MAA3B,CAET,CAAA,IAAIf,UAAJ,CAAe,CAAC,CAAD,CAAAI,OAAA,CAAWD,MAAX,CAAf,CAHT,EAMO,IAAIH,UAAJ,CAAee,MAAf,CARgC,CAWzCf,WAAAkB,QAAA,CAAqBC,QAAQ,CAACC,GAAD,CAAM,CACjC,GAAY,EAAZ,GAAIA,GAAJ,CAAgB,MAAOpB,WAAAqB,KAEvBtB,OAAAuB,MAAA,CAAaF,GAAb,CAAkBA,GAAAG,MAAA,CAAU,eAAV,CAAlB,CAA8C,oBAA9C,CACAxB,OAAAuB,MAAA,CAAaF,GAAAI,OAAb,CAA0B,CAA1B,CAA6B,CAA7B,CAAgC,gBAAhC,CACA,OAAO,KAAIxB,UAAJ,CAAeoB,GAAf;AAAoB,EAApB,CAL0B,CAQnCpB,WAAAK,UAAAoB,SAAA,CAAgCC,QAAQ,CAACC,IAAD,CAAO,CAC7C,IAAIxB,UAAY,IAAAG,oBAAA,EAAhB,CACIsB,MAAQ,EAGZ,KADcD,IACd,EADqBxB,SAAAqB,OACrB,CAAOI,KAAAJ,OAAP,CAAsBK,IAAtB,CAAA,CAA+BD,KAAAE,KAAA,CAAW,CAAX,CAE/B,OAAO,KAAIC,mBAAJ,CAAWH,KAAAxB,OAAA,CAAaD,SAAb,CAAX,CAPsC,CAU/CH,WAAAK,UAAA2B,MAAA,CAA6BC,QAAQ,CAACN,IAAD,CAAO,CAC1C,MAAO,KAAAF,SAAA,CAAcE,IAAd,CAAAO,SAAA,CAA6B,KAA7B,CADmC,CAzF0E;",
"sources":["node_modules/bigi/lib/convert.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$bigi$lib$convert\"] = function(global,process,require,module,exports,shadow$shims) {\n// FIXME: Kind of a weird way to throw exceptions, consider removing\nvar assert = require('assert')\nvar BigInteger = require('./bigi')\n\n/**\n * Turns a byte array into a big integer.\n *\n * This function will interpret a byte array as a big integer in big\n * endian notation.\n */\nBigInteger.fromByteArrayUnsigned = function(byteArray) {\n  // BigInteger expects a DER integer conformant byte array\n  if (byteArray[0] & 0x80) {\n    return new BigInteger([0].concat(byteArray))\n  }\n\n  return new BigInteger(byteArray)\n}\n\n/**\n * Returns a byte array representation of the big integer.\n *\n * This returns the absolute of the contained value in big endian\n * form. A value of zero results in an empty array.\n */\nBigInteger.prototype.toByteArrayUnsigned = function() {\n  var byteArray = this.toByteArray()\n  return byteArray[0] === 0 ? byteArray.slice(1) : byteArray\n}\n\nBigInteger.fromDERInteger = function(byteArray) {\n  return new BigInteger(byteArray)\n}\n\n/*\n * Converts BigInteger to a DER integer representation.\n *\n * The format for this value uses the most significant bit as a sign\n * bit.  If the most significant bit is already set and the integer is\n * positive, a 0x00 is prepended.\n *\n * Examples:\n *\n *      0 =>     0x00\n *      1 =>     0x01\n *     -1 =>     0xff\n *    127 =>     0x7f\n *   -127 =>     0x81\n *    128 =>   0x0080\n *   -128 =>     0x80\n *    255 =>   0x00ff\n *   -255 =>   0xff01\n *  16300 =>   0x3fac\n * -16300 =>   0xc054\n *  62300 => 0x00f35c\n * -62300 => 0xff0ca4\n*/\nBigInteger.prototype.toDERInteger = BigInteger.prototype.toByteArray\n\nBigInteger.fromBuffer = function(buffer) {\n  // BigInteger expects a DER integer conformant byte array\n  if (buffer[0] & 0x80) {\n    var byteArray = Array.prototype.slice.call(buffer)\n\n    return new BigInteger([0].concat(byteArray))\n  }\n\n  return new BigInteger(buffer)\n}\n\nBigInteger.fromHex = function(hex) {\n  if (hex === '') return BigInteger.ZERO\n\n  assert.equal(hex, hex.match(/^[A-Fa-f0-9]+/), 'Invalid hex string')\n  assert.equal(hex.length % 2, 0, 'Incomplete hex')\n  return new BigInteger(hex, 16)\n}\n\nBigInteger.prototype.toBuffer = function(size) {\n  var byteArray = this.toByteArrayUnsigned()\n  var zeros = []\n\n  var padding = size - byteArray.length\n  while (zeros.length < padding) zeros.push(0)\n\n  return new Buffer(zeros.concat(byteArray))\n}\n\nBigInteger.prototype.toHex = function(size) {\n  return this.toBuffer(size).toString('hex')\n}\n\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","assert","BigInteger","fromByteArrayUnsigned","BigInteger.fromByteArrayUnsigned","byteArray","concat","prototype","toByteArrayUnsigned","BigInteger.prototype.toByteArrayUnsigned","toByteArray","slice","fromDERInteger","BigInteger.fromDERInteger","toDERInteger","fromBuffer","BigInteger.fromBuffer","buffer","Array","call","fromHex","BigInteger.fromHex","hex","ZERO","equal","match","length","toBuffer","BigInteger.prototype.toBuffer","size","zeros","padding","push","Buffer","toHex","BigInteger.prototype.toHex","toString"]
}
