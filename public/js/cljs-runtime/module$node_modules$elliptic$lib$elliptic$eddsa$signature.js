shadow$provide.module$node_modules$elliptic$lib$elliptic$eddsa$signature=function(global,process,require,module,exports,shadow$shims){function Signature(eddsa,sig){this.eddsa=eddsa;"object"!==typeof sig&&(sig=parseBytes(sig));Array.isArray(sig)&&(sig={R:sig.slice(0,eddsa.encodingLength),S:sig.slice(eddsa.encodingLength)});assert(sig.R&&sig.S,"Signature without R or S");eddsa.isPoint(sig.R)&&(this._R=sig.R);sig.S instanceof BN&&(this._S=sig.S);this._Rencoded=Array.isArray(sig.R)?sig.R:sig.Rencoded;
this._Sencoded=Array.isArray(sig.S)?sig.S:sig.Sencoded}var BN=require("module$node_modules$bn_DOT_js$lib$bn"),utils=require("module$node_modules$elliptic$lib$elliptic").utils,assert=utils.assert;global=utils.cachedProperty;var parseBytes=utils.parseBytes;global(Signature,"S",function(){return this.eddsa.decodeInt(this.Sencoded())});global(Signature,"R",function(){return this.eddsa.decodePoint(this.Rencoded())});global(Signature,"Rencoded",function(){return this.eddsa.encodePoint(this.R())});global(Signature,
"Sencoded",function(){return this.eddsa.encodeInt(this.S())});Signature.prototype.toBytes=function(){return this.Rencoded().concat(this.Sencoded())};Signature.prototype.toHex=function(){return utils.encode(this.toBytes(),"hex").toUpperCase()};module.exports=Signature}
//# sourceMappingURL=module$node_modules$elliptic$lib$elliptic$eddsa$signature.js.map
