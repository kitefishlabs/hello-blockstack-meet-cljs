shadow$provide.module$node_modules$browserify_sign$browser$sign=function(global,process,require,module,exports,shadow$shims){function getKey(x,q,hash,algo){x=new shadow$shims.Buffer(x.toArray());if(x.length<q.byteLength()){var zeros=new shadow$shims.Buffer(q.byteLength()-x.length);zeros.fill(0);x=shadow$shims.Buffer.concat([zeros,x])}zeros=hash.length;hash=bits2int(hash,q);hash=hash.mod(q);hash=new shadow$shims.Buffer(hash.toArray());hash.length<q.byteLength()&&(q=new shadow$shims.Buffer(q.byteLength()-
hash.length),q.fill(0),hash=shadow$shims.Buffer.concat([q,hash]));q=hash;hash=new shadow$shims.Buffer(zeros);hash.fill(1);zeros=new shadow$shims.Buffer(zeros);zeros.fill(0);zeros=createHmac(algo,zeros).update(hash).update(new shadow$shims.Buffer([0])).update(x).update(q).digest();hash=createHmac(algo,zeros).update(hash).digest();zeros=createHmac(algo,zeros).update(hash).update(new shadow$shims.Buffer([1])).update(x).update(q).digest();hash=createHmac(algo,zeros).update(hash).digest();return{k:zeros,
v:hash}}function bits2int(obits,q){var bits=new BN(obits);obits=(obits.length<<3)-q.bitLength();0<obits&&bits.ishrn(obits);return bits}function makeKey(q,kv,algo){var t;do{for(t=new shadow$shims.Buffer(0);8*t.length<q.bitLength();)kv.v=createHmac(algo,kv.k).update(kv.v).digest(),t=shadow$shims.Buffer.concat([t,kv.v]);t=bits2int(t,q);kv.k=createHmac(algo,kv.k).update(kv.v).update(new shadow$shims.Buffer([0])).digest();kv.v=createHmac(algo,kv.k).update(kv.v).digest()}while(-1!==t.cmp(q));return t}var createHmac=
require("module$node_modules$create_hmac$browser"),crt=require("module$node_modules$browserify_rsa$index"),EC=require("module$node_modules$elliptic$lib$elliptic").ec,BN=require("module$node_modules$bn_DOT_js$lib$bn"),parseKeys=require("module$node_modules$parse_asn1$index"),curves=require("module$node_modules$browserify_sign$browser$curves_json");module.exports=function(hash$jscomp$0,key,hashType,signType,tag){key=parseKeys(key);if(key.curve){if("ecdsa"!==signType&&"ecdsa/rsa"!==signType)throw Error("wrong private key type");
hashType=hash$jscomp$0;hash$jscomp$0=curves[key.curve.join(".")];if(!hash$jscomp$0)throw Error("unknown curve "+key.curve.join("."));hashType=(new EC(hash$jscomp$0)).keyFromPrivate(key.privateKey).sign(hashType);return new shadow$shims.Buffer(hashType.toDER())}if("dsa"===key.type){if("dsa"!==signType)throw Error("wrong private key type");var hash=hash$jscomp$0;hash$jscomp$0=key.params.priv_key;signType=key.params.p;tag=key.params.q;key=key.params.g;var r=new BN(0),H=bits2int(hash,tag).mod(tag);var k=
!1;for(hash=getKey(hash$jscomp$0,tag,hash,hashType);!1===k;){r=k=makeKey(tag,hash,hashType);var q=tag;r=key.toRed(BN.mont(signType)).redPow(r).fromRed().mod(q);k=k.invm(tag).imul(H.add(hash$jscomp$0.mul(r))).mod(tag);0===k.cmpn(0)&&(k=!1,r=new BN(0))}hashType=k;key=r.toArray();hashType=hashType.toArray();key[0]&128&&(key=[0].concat(key));hashType[0]&128&&(hashType=[0].concat(hashType));hash$jscomp$0=[48,key.length+hashType.length+4,2,key.length];hash$jscomp$0=hash$jscomp$0.concat(key,[2,hashType.length],
hashType);return new shadow$shims.Buffer(hash$jscomp$0)}if("rsa"!==signType&&"ecdsa/rsa"!==signType)throw Error("wrong private key type");hash$jscomp$0=shadow$shims.Buffer.concat([tag,hash$jscomp$0]);signType=key.modulus.byteLength();for(hashType=[0,1];hash$jscomp$0.length+hashType.length+1<signType;)hashType.push(255);hashType.push(0);for(signType=-1;++signType<hash$jscomp$0.length;)hashType.push(hash$jscomp$0[signType]);return crt(hashType,key)};module.exports.getKey=getKey;module.exports.makeKey=
makeKey}
//# sourceMappingURL=module$node_modules$browserify_sign$browser$sign.js.map
