shadow$provide.module$node_modules$bitcoinjs_lib$src$payments$p2ms=function(global,process,require,module,exports,shadow$shims){function stacksEqual(a,b){return a.length!==b.length?!1:a.every(function(x,i){return x.equals(b[i])})}var lazy=require("module$node_modules$bitcoinjs_lib$src$payments$lazy"),typef=require("module$node_modules$typeforce$index"),OPS=require("module$node_modules$bitcoin_ops$index_json"),ecc=require("module$node_modules$tiny_secp256k1$ecurve"),bscript=require("module$node_modules$bitcoinjs_lib$src$script"),
BITCOIN_NETWORK=require("module$node_modules$bitcoinjs_lib$src$networks").bitcoin,OP_INT_BASE=OPS.OP_RESERVED;module.exports=function(a,opts){function isAcceptableSignature(x){return bscript.isCanonicalScriptSignature(x)||opts.allowIncomplete&&x===OPS.OP_0}function decode(output){decoded||(decoded=!0,chunks=bscript.decompile(output),o.m=chunks[0]-OP_INT_BASE,o.n=chunks[chunks.length-2]-OP_INT_BASE,o.pubkeys=chunks.slice(1,-2))}if(!(a.input||a.output||a.pubkeys&&void 0!==a.m||a.signatures))throw new TypeError("Not enough data");
opts=Object.assign({validate:!0},opts||{});typef({network:typef.maybe(typef.Object),m:typef.maybe(typef.Number),n:typef.maybe(typef.Number),output:typef.maybe(typef.Buffer),pubkeys:typef.maybe(typef.arrayOf(ecc.isPoint)),signatures:typef.maybe(typef.arrayOf(isAcceptableSignature)),input:typef.maybe(typef.Buffer)},a);var o={network:a.network||BITCOIN_NETWORK},chunks,decoded=!1;lazy.prop(o,"output",function(){if(a.m&&o.n&&a.pubkeys)return bscript.compile([].concat(OP_INT_BASE+a.m,a.pubkeys,OP_INT_BASE+
o.n,OPS.OP_CHECKMULTISIG))});lazy.prop(o,"m",function(){if(o.output)return decode(o.output),o.m});lazy.prop(o,"n",function(){if(o.pubkeys)return o.pubkeys.length});lazy.prop(o,"pubkeys",function(){if(a.output)return decode(a.output),o.pubkeys});lazy.prop(o,"signatures",function(){if(a.input)return bscript.decompile(a.input).slice(1)});lazy.prop(o,"input",function(){if(a.signatures)return bscript.compile([OPS.OP_0].concat(a.signatures))});lazy.prop(o,"witness",function(){if(o.input)return[]});if(opts.validate){if(a.output){decode(a.output);
if(!typef.Number(chunks[0]))throw new TypeError("Output is invalid");if(!typef.Number(chunks[chunks.length-2]))throw new TypeError("Output is invalid");if(chunks[chunks.length-1]!==OPS.OP_CHECKMULTISIG)throw new TypeError("Output is invalid");if(0>=o.m||16<o.n||o.m>o.n||o.n!==chunks.length-3)throw new TypeError("Output is invalid");if(!o.pubkeys.every(function(x){return ecc.isPoint(x)}))throw new TypeError("Output is invalid");if(void 0!==a.m&&a.m!==o.m)throw new TypeError("m mismatch");if(void 0!==
a.n&&a.n!==o.n)throw new TypeError("n mismatch");if(a.pubkeys&&!stacksEqual(a.pubkeys,o.pubkeys))throw new TypeError("Pubkeys mismatch");}if(a.pubkeys){if(void 0!==a.n&&a.n!==a.pubkeys.length)throw new TypeError("Pubkey count mismatch");o.n=a.pubkeys.length;if(o.n<o.m)throw new TypeError("Pubkey count cannot be less than m");}if(a.signatures){if(a.signatures.length<o.m)throw new TypeError("Not enough signatures provided");if(a.signatures.length>o.m)throw new TypeError("Too many signatures provided");
}if(a.input){if(a.input[0]!==OPS.OP_0)throw new TypeError("Input is invalid");if(0===o.signatures.length||!o.signatures.every(isAcceptableSignature))throw new TypeError("Input has invalid signature(s)");if(a.signatures&&!stacksEqual(a.signatures.equals(o.signatures)))throw new TypeError("Signature mismatch");if(void 0!==a.m&&a.m!==a.signatures.length)throw new TypeError("Signature count mismatch");}}return Object.assign(o,a)}}
//# sourceMappingURL=module$node_modules$bitcoinjs_lib$src$payments$p2ms.js.map
