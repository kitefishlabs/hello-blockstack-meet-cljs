shadow$provide.module$node_modules$bitcoinjs_lib$src$block=function(global,process,require,module,exports,shadow$shims){function Block(){this.version=1;this.merkleRoot=this.prevHash=null;this.nonce=this.bits=this.timestamp=0}var Buffer=require("module$node_modules$safe_buffer$index").Buffer,bcrypto=require("module$node_modules$bitcoinjs_lib$src$crypto"),fastMerkleRoot=require("module$node_modules$merkle_lib$fastRoot"),typeforce=require("module$node_modules$typeforce$index"),types=require("module$node_modules$bitcoinjs_lib$src$types"),
varuint=require("module$node_modules$varuint_bitcoin$index"),Transaction=require("module$node_modules$bitcoinjs_lib$src$transaction");Block.fromBuffer=function(buffer){function readSlice(n){offset+=n;return buffer.slice(offset-n,offset)}function readUInt32(){var i=buffer.readUInt32LE(offset);offset+=4;return i}function readTransaction(){var tx=Transaction.fromBuffer(buffer.slice(offset),!0);offset+=tx.byteLength();return tx}if(80>buffer.length)throw Error("Buffer too small (\x3c 80 bytes)");var offset=
0,block=new Block;block.version=function(){var i=buffer.readInt32LE(offset);offset+=4;return i}();block.prevHash=readSlice(32);block.merkleRoot=readSlice(32);block.timestamp=readUInt32();block.bits=readUInt32();block.nonce=readUInt32();if(80===buffer.length)return block;var nTransactions=function(){var vi=varuint.decode(buffer,offset);offset+=varuint.decode.bytes;return vi}();block.transactions=[];for(var i$jscomp$0=0;i$jscomp$0<nTransactions;++i$jscomp$0){var tx$jscomp$0=readTransaction();block.transactions.push(tx$jscomp$0)}return block};
Block.prototype.byteLength=function(headersOnly){return headersOnly||!this.transactions?80:80+varuint.encodingLength(this.transactions.length)+this.transactions.reduce(function(a,x){return a+x.byteLength()},0)};Block.fromHex=function(hex){return Block.fromBuffer(Buffer.from(hex,"hex"))};Block.prototype.getHash=function(){return bcrypto.hash256(this.toBuffer(!0))};Block.prototype.getId=function(){return this.getHash().reverse().toString("hex")};Block.prototype.getUTCDate=function(){var date=new Date(0);
date.setUTCSeconds(this.timestamp);return date};Block.prototype.toBuffer=function(headersOnly){function writeSlice(slice){slice.copy(buffer,offset);offset+=slice.length}function writeUInt32(i){buffer.writeUInt32LE(i,offset);offset+=4}var buffer=Buffer.allocUnsafe(this.byteLength(headersOnly)),offset=0;buffer.writeInt32LE(this.version,offset);offset+=4;writeSlice(this.prevHash);writeSlice(this.merkleRoot);writeUInt32(this.timestamp);writeUInt32(this.bits);writeUInt32(this.nonce);if(headersOnly||!this.transactions)return buffer;
varuint.encode(this.transactions.length,buffer,offset);offset+=varuint.encode.bytes;this.transactions.forEach(function(tx){var txSize=tx.byteLength();tx.toBuffer(buffer,offset);offset+=txSize});return buffer};Block.prototype.toHex=function(headersOnly){return this.toBuffer(headersOnly).toString("hex")};Block.calculateTarget=function(bits){var exponent=((bits&4278190080)>>24)-3;bits&=8388607;var target=Buffer.alloc(32,0);target.writeUInt32BE(bits,28-exponent);return target};Block.calculateMerkleRoot=
function(transactions){typeforce([{getHash:types.Function}],transactions);if(0===transactions.length)throw TypeError("Cannot compute merkle root for zero transactions");transactions=transactions.map(function(transaction){return transaction.getHash()});return fastMerkleRoot(transactions,bcrypto.hash256)};Block.prototype.checkMerkleRoot=function(){if(!this.transactions)return!1;var actualMerkleRoot=Block.calculateMerkleRoot(this.transactions);return 0===this.merkleRoot.compare(actualMerkleRoot)};Block.prototype.checkProofOfWork=
function(){var hash=this.getHash().reverse(),target=Block.calculateTarget(this.bits);return 0>=hash.compare(target)};module.exports=Block}
//# sourceMappingURL=module$node_modules$bitcoinjs_lib$src$block.js.map
