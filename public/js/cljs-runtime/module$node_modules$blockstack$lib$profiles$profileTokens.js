shadow$provide.module$node_modules$blockstack$lib$profiles$profileTokens=function(global,process,require,module,exports,shadow$shims){function verifyProfileToken(token,publicKeyOrAddress){var decodedToken=(0,_jsontokens.decodeToken)(token),payload=decodedToken.payload;if(payload.hasOwnProperty("subject")){if(!payload.subject.hasOwnProperty("publicKey"))throw Error("Token doesn't have a subject public key");}else throw Error("Token doesn't have a subject");if(payload.hasOwnProperty("issuer")){if(!payload.issuer.hasOwnProperty("publicKey"))throw Error("Token doesn't have an issuer public key");
}else throw Error("Token doesn't have an issuer");if(!payload.hasOwnProperty("claim"))throw Error("Token doesn't have a claim");payload=payload.issuer.publicKey;var publicKeyBuffer=new shadow$shims.Buffer(payload,"hex"),compressedKeyPair=_bitcoinjsLib.ECPair.fromPublicKey(publicKeyBuffer,{compressed:!0});compressedKeyPair=(0,_utils.ecPairToAddress)(compressedKeyPair);publicKeyBuffer=_bitcoinjsLib.ECPair.fromPublicKey(publicKeyBuffer,{compressed:!1});publicKeyBuffer=(0,_utils.ecPairToAddress)(publicKeyBuffer);
if(publicKeyOrAddress!==payload&&publicKeyOrAddress!==compressedKeyPair&&publicKeyOrAddress!==publicKeyBuffer)throw Error("Token issuer public key does not match the verifying value");publicKeyOrAddress=new _jsontokens.TokenVerifier(decodedToken.header.alg,payload);if(!publicKeyOrAddress)throw Error("Invalid token verifier");if(!publicKeyOrAddress.verify(token))throw Error("Token verification failed");return decodedToken}Object.defineProperty(exports,"__esModule",{value:!0});exports.signProfileToken=
function(profile,privateKey){var subject=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null,issuer=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null,signingAlgorithm=4<arguments.length&&void 0!==arguments[4]?arguments[4]:"ES256K",issuedAt=5<arguments.length&&void 0!==arguments[5]?arguments[5]:new Date,expiresAt=6<arguments.length&&void 0!==arguments[6]?arguments[6]:(0,_utils.nextYear)();if("ES256K"!==signingAlgorithm)throw Error("Signing algorithm not supported");var publicKey=
_jsontokens.SECP256K1Client.derivePublicKey(privateKey);null===subject&&(subject={publicKey:publicKey});null===issuer&&(issuer={publicKey:publicKey});signingAlgorithm=new _jsontokens.TokenSigner(signingAlgorithm,privateKey);subject={jti:(0,_utils.makeUUID4)(),iat:issuedAt.toISOString(),exp:expiresAt.toISOString(),subject:subject,issuer:issuer,claim:profile};return signingAlgorithm.sign(subject)};exports.wrapProfileToken=function(token){return{token:token,decodedToken:(0,_jsontokens.decodeToken)(token)}};
exports.verifyProfileToken=verifyProfileToken;exports.extractProfile=function(token){var publicKeyOrAddress=1<arguments.length&&void 0!==arguments[1]?arguments[1]:null;publicKeyOrAddress=publicKeyOrAddress?verifyProfileToken(token,publicKeyOrAddress):(0,_jsontokens.decodeToken)(token);var profile={};publicKeyOrAddress.hasOwnProperty("payload")&&publicKeyOrAddress.payload.hasOwnProperty("claim")&&(profile=publicKeyOrAddress.payload.claim);return profile};var _bitcoinjsLib=require("module$node_modules$bitcoinjs_lib$src$index"),
_jsontokens=require("module$node_modules$jsontokens$lib$index"),_utils=require("module$node_modules$blockstack$lib$utils")}
//# sourceMappingURL=module$node_modules$blockstack$lib$profiles$profileTokens.js.map
