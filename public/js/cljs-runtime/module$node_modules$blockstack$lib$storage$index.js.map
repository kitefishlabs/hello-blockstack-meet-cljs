{
"version":3,
"file":"module$node_modules$blockstack$lib$storage$index.js",
"lineCount":22,
"mappings":"AAAAA,cAAA,iDAAA,CAAqE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,OAAhB,CAAwBC,MAAxB,CAA+BC,OAA/B,CAAuCC,YAAvC,CAAqD,CA+ClIC,QAASA,kBAAiB,CAACC,IAAD,CAAOC,QAAP,CAAiBC,SAAjB,CAA4B,CACpD,IAAIC,kBAAuC,CAAnB,CAAAC,SAAAC,OAAA,EAAyCC,IAAAA,EAAzC,GAAwBF,SAAA,CAAU,CAAV,CAAxB,CAAqDA,SAAA,CAAU,CAAV,CAArD,CAAoE,IAE5F,OAAO,CAAC,CAAA,CAAGG,SAAAC,cAAJ,EAA6BP,QAA7B,CAAuCE,iBAAvC,CAAAM,KAAA,CAA+D,QAAS,CAACC,OAAD,CAAU,CACvF,MAAIA,QAAAC,eAAA,CAAuB,MAAvB,CAAJ,CACMD,OAAAE,KAAAD,eAAA,CAA4BT,SAA5B,CAAJ,CACSQ,OAAAE,KAAA,CAAaV,SAAb,CADT,CAGS,IAJX,CAOS,IAR8E,CAAlF,CAAAO,KAAA,CAUC,QAAS,CAACI,SAAD,CAAY,CAC3B,MAAIA,UAAJ,CAES,EAFT;AACeA,SAAAC,QAAAC,CAAkB,aAAlBA,CAAiC,KAAjCA,CADf,CAEuBf,IAFvB,CAIS,IALkB,CAVtB,CAH6C,CA+BtDgB,QAASA,eAAc,CAACC,OAAD,CAAUC,OAAV,CAAmB,CAEpCC,OAAAA,CAAMC,MAAAC,OAAA,CAAc,EAAd,CADKC,CAAEC,UAAW,IAAbD,CACL,CAA4BJ,OAA5B,CACV,IAAI,CAACC,OAAAI,UAAL,CAAoB,CAClB,IAAIC,WAAa,CAAC,CAAA,CAAGC,KAAAC,aAAJ,GAAAC,cACjBR,QAAAI,UAAA,CAAgB,CAAC,CAAA,CAAGK,KAAAC,wBAAJ,EAAmCL,UAAnC,CAFE,CAKhBM,OAAAA,CAAe,CAAC,CAAA,CAAGC,WAAAC,aAAJ,EAA8Bb,OAAAI,UAA9B,CAA6CN,OAA7C,CACnB,OAAOgB,KAAAC,UAAA,CAAeJ,OAAf,CATiC,CAqB1CK,QAASA,eAAc,CAAClB,OAAD,CAAUC,OAAV,CAAmB,CAGpCM,OAAAA,CADMJ,MAAAC,OAAAF,CAAc,EAAdA,CADKG,CAAEE,WAAY,IAAdF,CACLH,CAA4BD,OAA5BC,CACOK,WACZA,QAAL,GACEA,OADF;AACe,CAAC,CAAA,CAAGC,KAAAC,aAAJ,GAAAC,cADf,CAIA,IAAI,CACF,IAAIG,aAAeG,IAAAG,MAAA,CAAWnB,OAAX,CACnB,OAAO,CAAC,CAAA,CAAGc,WAAAM,aAAJ,EAA8Bb,OAA9B,CAA0CM,YAA1C,CAFL,CAGF,MAAOQ,GAAP,CAAY,CACZ,GAAIA,GAAJ,WAAmBC,YAAnB,CACE,KAAUC,MAAJ,CAAU,6HAAV,CAAN,CAEA,KAAMF,IAAN,CAJU,CAX0B,CAwB1CG,QAASA,eAAc,CAACC,GAAD,CAAMzC,QAAN,CAAgBE,iBAAhB,CAAmC,CACxD,MAAOwC,QAAAC,QAAA,EAAAnC,KAAA,CAAuB,QAAS,EAAG,CACxC,MAAIR,SAAJ,CACSF,iBAAA,CAAkB,GAAlB,CAAuBE,QAAvB,CAAiCyC,GAAjC,CAAsCvC,iBAAtC,CADT,CAGS,CAAC,CAAA,CAAG0C,IAAAC,+BAAJ,GAAArC,KAAA,CAAgD,QAAS,CAACsC,aAAD,CAAgB,CAC9E,MAAO,CAAC,CAAA;AAAGF,IAAAG,eAAJ,EAAyB,GAAzB,CAA8BD,aAA9B,CADuE,CAAzE,CAJ+B,CAAnC,CAAAtC,KAAA,CAQC,QAAS,CAACwC,OAAD,CAAU,CACrBC,OAAAA,CAAUD,OAAAE,MAAA,CAAc,mCAAd,CACd,IAAI,CAACD,OAAL,CACE,KAAUV,MAAJ,CAAU,8BAAV,CAAN,CAEF,MAAOU,QAAA,CAAQA,OAAA7C,OAAR,CAAyB,CAAzB,CALkB,CARpB,CADiD,CAsB1D+C,QAASA,gBAAe,CAACpD,IAAD,CAAO0C,GAAP,CAAYzC,QAAZ,CAAsBE,iBAAtB,CAAyCkD,SAAzC,CAAoD,CAC1E,MAAOV,QAAAC,QAAA,EAAAnC,KAAA,CAAuB,QAAS,EAAG,CACxC,MAAIR,SAAJ,CACSF,iBAAA,CAAkBC,IAAlB,CAAwBC,QAAxB,CAAkCyC,GAAlC,CAAuCvC,iBAAvC,CADT,CAGS,CAAC,CAAA,CAAG0C,IAAAC,+BAAJ,GAAArC,KAAA,CAAgD,QAAS,CAACsC,aAAD,CAAgB,CAC9E,MAAO,CAAC,CAAA,CAAGF,IAAAG,eAAJ,EAAyBhD,IAAzB;AAA+B+C,aAA/B,CADuE,CAAzE,CAJ+B,CAAnC,CAAAtC,KAAA,CAQC,QAAS,CAAC6C,OAAD,CAAU,CACzB,MAAO,KAAIX,OAAJ,CAAY,QAAS,CAACC,OAAD,CAAUW,MAAV,CAAkB,CACvCD,OAAL,CAGEV,OAAA,CAAQU,OAAR,CAHF,CACEC,MAAA,CAAO,IAAP,CAF0C,CAAvC,CADkB,CARpB,CAAA9C,KAAA,CAgBC,QAAS,CAAC6C,OAAD,CAAU,CACzB,MAAOE,MAAA,CAAMF,OAAN,CADkB,CAhBpB,CAAA7C,KAAA,CAkBC,QAAS,CAACgD,QAAD,CAAW,CAC1B,GAAwB,GAAxB,GAAIA,QAAAC,OAAJ,CAA6B,CAC3B,GAAwB,GAAxB,GAAID,QAAAC,OAAJ,CAEE,MADAC,QAAAC,OAAAC,MAAA,CAAqB,UAArB,CAAkC7D,IAAlC,CAAyC,+BAAzC,CACO,CAAA,IAEP,MAAUwC,MAAJ,CAAU,UAAV,CAAuBxC,IAAvB,CAA8B,2BAA9B,CAA4DyD,QAAAC,OAA5D,CAAN,CALyB,CAQ7B,IAAII,YAAcL,QAAAM,QAAAC,IAAA,CAAqB,cAArB,CAClB,OAAIX,UAAJ,EAAiC,IAAjC,GAAiBS,WAAjB,EAAyCA,WAAAG,WAAA,CAAuB,MAAvB,CAAzC;AAA2F,kBAA3F,GAA2EH,WAA3E,CACSL,QAAAS,KAAA,EADT,CAGST,QAAAU,YAAA,EAbiB,CAlBrB,CADmE,CA0C5EC,QAASA,yBAAwB,CAACpE,IAAD,CAAOmB,GAAP,CAAY,CAK3C,MAAOwB,QAAA0B,IAAA,CAAY,CAACjB,eAAA,CAAgBpD,IAAhB,CAAsBmB,GAAAuB,IAAtB,CAA+BvB,GAAAlB,SAA/B,CAA6CkB,GAAAhB,kBAA7C,CAAoE,CAAA,CAApE,CAAD,CAA6EiD,eAAA,CAAgB,EAAhB,CAAqBpD,IAArB,CAA4BsE,qBAA5B,CAAmDnD,GAAAuB,IAAnD,CAA4DvB,GAAAlB,SAA5D,CAA0EkB,GAAAhB,kBAA1E,CAAiG,CAAA,CAAjG,CAA7E,CAAqLsC,cAAA,CAAetB,GAAAuB,IAAf,CAAwBvB,GAAAlB,SAAxB,CAAsCkB,GAAAhB,kBAAtC,CAArL,CAAZ,CAAAM,KAAA,CAAqQ,QAAS,CAAC8D,IAAD,CAAO,CAAA,IACtRC,MAAQC,cAAA,CAAeF,IAAf,CAAqB,CAArB,CACRG,KAAAA,CAAeF,KAAA,CAAM,CAAN,CAFuQ,KAGtRG,kBAAoBH,KAAA,CAAM,CAAN,CACpBI,MAAAA,CAAcJ,KAAA,CAAM,CAAN,CAElB,IAAI,CAACE,IAAL,CACE,MAAOA,KAET,IAAI,CAACE,KAAL,CACE,KAAM,KAAIC,OAAAC,2BAAJ,CAAuC,kDAAvC;AAAkG9E,IAAlG,CAAN,CAEF,GAAI,CAAC2E,iBAAL,EAAuD,QAAvD,GAA0B,MAAOA,kBAAjC,CACE,KAAM,KAAIE,OAAAC,2BAAJ,CAAuC,uCAAvC,EAAkF9E,IAAlF,CAAyF,gBAAzF,CAA4GA,IAA5G,CAAmHsE,qBAAnH,EAAN,CAEF,IAAIS,UAAY,IAAK,EAArB,CACIxD,UAAY,IAAK,EACrB,IAAI,CACF,IAAIyD,UAAY/C,IAAAG,MAAA,CAAWuC,iBAAX,CAChBI,UAAA,CAAYC,SAAAD,UACZxD,UAAA,CAAYyD,SAAAzD,UAHV,CAIF,MAAOe,GAAP,CAAY,CACZ,GAAIA,GAAJ,WAAmBC,YAAnB,CACE,KAAUC,MAAJ,CAAU,yCAAV,EAAuD,SAAvD,CAAmExC,IAAnE,CAA0EsE,qBAA1E,CAAkG,GAAlG,EAAyG,gCAAzG,CAAN;AAEA,KAAMhC,IAAN,CAJU,CAOV2C,SAAAA,CAAgB,CAAC,CAAA,CAAGrD,KAAAsD,mBAAJ,EAA8B3D,SAA9B,CACpB,IAAIqD,KAAJ,GAAoBK,SAApB,CACE,KAAM,KAAIJ,OAAAC,2BAAJ,CAAuC,yBAAvC,CAAmEG,SAAnE,CAAmF,WAAnF,EAAmG,uBAAnG,CAA6HL,KAA7H,CAA2I,GAA3I,EAAN,CACK,GAAK,CAAC,CAAA,CAAG7C,WAAAoD,YAAJ,EAA6BC,mBAAAC,KAAA,CAAYX,IAAZ,CAA7B,CAAwDnD,SAAxD,CAAmEwD,SAAnE,CAAL,CAGL,MAAOL,KAFP,MAAM,KAAIG,OAAAC,2BAAJ,CAAuC,yCAAvC,EAAoF,QAApF,CAA+F9E,IAA/F,CAAsG,eAAtG,CAAwHA,IAAxH,CAA+HsE,qBAA/H,EAAN,CAhCwR,CAArR,CALoC,CAkD7CgB,QAASA,8BAA6B,CAACtF,IAAD;AAAOuF,cAAP,CAAuB7C,GAAvB,CAA4BzC,QAA5B,CAAsCE,iBAAtC,CAAyD,CAC7F,IAAIwB,cAAgB,CAAC,CAAA,CAAGF,KAAAC,aAAJ,GAAAC,cAChB6D,cAAAA,CAAe,CAAC,CAAA,CAAG5D,KAAAC,wBAAJ,EAAmCF,aAAnC,CAEnB,KAAI8D,eAAiB,IAAK,EACtBxF,SAAJ,CACEwF,cADF,CACmBhD,cAAA,CAAeC,GAAf,CAAoBzC,QAApB,CAA8BE,iBAA9B,CADnB,EAGMuF,GACJ,CADc,CAAC,CAAA,CAAG9D,KAAAsD,mBAAJ,EAA8BM,aAA9B,CACd,CAAAC,cAAA,CAAiB9C,OAAAC,QAAA,CAAgB8C,GAAhB,CAJnB,CAOA,OAAOD,eAAAhF,KAAA,CAAoB,QAAS,CAACiF,OAAD,CAAU,CAC5C,GAAI,CAACA,OAAL,CACE,KAAM,KAAIb,OAAAC,2BAAJ,CAAuC,kDAAvC;AAAkG9E,IAAlG,CAAN,CAEF,IAAIgF,UAAY,IAAK,EACrB,IAAI,CACFA,SAAA,CAAY/C,IAAAG,MAAA,CAAWmD,cAAX,CADV,CAEF,MAAOjD,GAAP,CAAY,CACZ,GAAIA,GAAJ,WAAmBC,YAAnB,CACE,KAAUC,MAAJ,CAAU,oJAAV,CAAN,CAEA,KAAMF,IAAN,CAJU,CAOd,IAAIyC,UAAYC,SAAAD,UAAhB,CACIY,gBAAkBX,SAAAzD,UAClBqE,UAAAA,CAAaZ,SAAAY,WACjB,KAAIX,cAAgB,CAAC,CAAA,CAAGrD,KAAAsD,mBAAJ,EAA8BS,eAA9B,CAEpB,IAAKA,eAAL,EAAyBC,SAAzB,EAAwCb,SAAxC,CAEO,CAAA,GAAIE,aAAJ;AAAsBS,OAAtB,CACL,KAAM,KAAIb,OAAAC,2BAAJ,CAAuC,yBAAvC,CAAmEG,aAAnE,CAAmF,WAAnF,EAAmG,uBAAnG,CAA6HS,OAA7H,CAAuI,GAAvI,EAAN,CACK,GAAK,CAAC,CAAA,CAAG3D,WAAAoD,YAAJ,EAA6BS,SAA7B,CAAyCD,eAAzC,CAA0DZ,SAA1D,CAAL,CAGL,MAAO5C,eAAA,CAAeyD,SAAf,CAFP,MAAM,KAAIf,OAAAC,2BAAJ,CAAuC,iDAAvC,CAAiG9E,IAAjG,CAAN,CAHK,CADL,KAAM,KAAI6E,OAAAC,2BAAJ,CAAuC,uDAAvC,CAAuG9E,IAAvG,CAAN,CApB0C,CAAvC,CAZsF,CAmO/F6F,QAASA,cAAa,CAACC,SAAD,CAAYC,IAAZ,CAAkBC,SAAlB;AAA6BC,SAA7B,CAAwCC,QAAxC,CAAkD,CACtE,GAAgB,KAAhB,CAAIF,SAAJ,CAGE,KAAUxD,MAAJ,CAAU,0BAAV,CAAN,CAGF,IAAI2D,WAAa,IAAK,EAClBC,KAAAA,CAAcnE,IAAAC,UAAA,CAAe,CAAE6D,KAAMA,IAAR,CAAf,CAYlB,OAAOvC,MAAA,CAAMsC,SAAAO,OAAN,CAAyB,cAAzB,CAA0CP,SAAAJ,QAA1C,CAVYY,CACjBC,OAAQ,MADSD,CAEjBvC,QAAS,CACP,eAAgB,kBADT,CAEP,iBAAkB,EAAlB,CAAuBqC,IAAA/F,OAFhB,CAGPmG,cAAe,SAAfA,CAA2BV,SAAAW,MAHpB,CAFQH,CAOjBI,KAAMN,IAPWE,CAUZ,CAAA7F,KAAA,CAAgF,QAAS,CAACgD,QAAD,CAAW,CACzG0C,UAAA,CAAa1C,QAAAC,OACb,IAAkB,GAAlB,EAAIyC,UAAJ,CACE,KAAU3D,MAAJ,CAAU,oCAAV,CAAiD2D,UAAjD,CAAN,CAEF,MAAO1C,SAAAS,KAAA,EALkG,CAApG,CAAAzD,KAAA,CAMC,QAAS,CAACkG,YAAD,CAAe,CAC9B,MAAO1E,KAAAG,MAAA,CAAWuE,YAAX,CADuB,CANzB,CAAAlG,KAAA,CAQC,QAAS,CAACmG,YAAD,CAAe,CAC9B,IAAIC;AAAUD,YAAAC,QACVC,aAAAA,CAAWF,YAAAb,KACf,IAAgB,IAAhB,GAAIc,OAAJ,EAAoCvG,IAAAA,EAApC,GAAwBuG,OAAxB,CAGE,KAAUrE,MAAJ,CAAU,oCAAV,CAAN,CAEF,IAAK,IAAIuE,EAAI,CAAb,CAAgBA,CAAhB,CAAoBF,OAAAxG,OAApB,CAAoC0G,CAAA,EAApC,CAEE,GAAI,CADKb,QAAAc,CAASH,OAAA,CAAQE,CAAR,CAATC,CACT,CAEE,MAAOrE,QAAAC,QAAA,CAAgBqD,SAAhB,CAA4Bc,CAA5B,CAGX,OAAID,aAAJ,EAAiC,CAAjC,CAAgBD,OAAAxG,OAAhB,CAESwF,aAAA,CAAcC,SAAd,CAAyBgB,YAAzB,CAAmCd,SAAnC,CAA+C,CAA/C,CAAkDC,SAAlD,CAA8DY,OAAAxG,OAA9D,CAA8E6F,QAA9E,CAFT,CAKSvD,OAAAC,QAAA,CAAgBqD,SAAhB,CAA4BY,OAAAxG,OAA5B,CApBqB,CARzB,CApB+D,CA7cxEe,MAAA6F,eAAA,CAAsBpH,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CqH,MAAO,CAAA,CADoC,CAA7C,CAGArH,QAAAsH,0BAAA,CAAoCtH,OAAAuH,gBAApC;AAA8DvH,OAAAwH,iBAA9D,CAAyF/G,IAAAA,EAEzF,KAAImE,eAAiB,QAAS,EAAG,CAA4Y,MAAO,SAAS,CAAC6C,GAAD,CAAMP,CAAN,CAAS,CAAE,GAAIQ,KAAAC,QAAA,CAAcF,GAAd,CAAJ,CAA0B,MAAOA,IAAY,IAAIG,MAAAC,SAAJ,GAAuBtG,OAAA,CAAOkG,GAAP,CAAvB,CAAoC,CAArd,IAAIK,KAAO,EAAX,CAAmBC,GAAK,CAAA,CAAxB,CAAkCC,GAAK,CAAA,CAAvC,CAAkDC,GAAKxH,IAAAA,EAAW,IAAI,CAAE,IAAF,IAAWyH,GAA2ZT,GAAtZ,CAAIG,MAAAC,SAAJ,CAAA,EAAhB,CAAwCM,EAAtC,CAA0C,EAAEJ,EAAF,CAAOK,CAACD,EAADC,CAAMF,EAAAG,KAAA,EAAND,MAAP,CAA1C,GAAsFN,IAAAQ,KAAA,CAAUH,EAAAd,MAAV,CAAyB,CAA0TH,CAAAA,CAA1T,EAAKY,IAAAtH,OAAL,GAA0T0G,CAAza,EAAyEa,EAAzE,CAA8E,CAAA,CAA9E,EAAF,CAAoJ,MAAOtF,GAAP,CAAY,CAAEuF,EAAW,CAAN,CAAA,CAAM,CAAAC,EAAA,CAAKxF,GAAlB,CAApK,OAAqM,CAAE,GAAI,CAAE,GAAI,CAACsF,EAAL,EAAWG,EAAA,CAAG,QAAH,CAAX,CAAyBA,EAAA,CAAG,QAAH,CAAA,EAA3B,CAAJ,OAAyD,CAAE,GAAIF,EAAJ,CAAQ,KAAMC,GAAN,CAAV,CAA3D,CAAgN,MAAtHH,KAAoH,CAAyC,KAAM,KAAIS,SAAJ,CAAc,sDAAd,CAAN,CAA5H,CAAra,CAAZ,EAGrBvI,QAAAE,kBAAA;AAA4BA,iBAC5BF,QAAAmB,eAAA,CAAyBA,cACzBnB,QAAAsC,eAAA,CAAyBA,cACzBtC,QAAAwI,QAAA,CA0RAA,QAAgB,CAACrI,IAAD,CAAOkB,OAAP,CAAgB,CAS9B,IAAIC,IAAMC,MAAAC,OAAA,CAAc,EAAd,CARKC,CACbgH,QAAS,CAAA,CADIhH,CAEbiH,OAAQ,CAAA,CAFKjH,CAGbrB,SAAU,IAHGqB,CAIboB,IAAK8F,MAAAC,SAAAC,OAJQpH,CAKbnB,kBAAmB,IALNmB,CAQL,CAA4BJ,OAA5B,CAIV,OAAIC,IAAAoH,OAAJ,EAAkB,CAACpH,GAAAmH,QAAnB,CACSlE,wBAAA,CAAyBpE,IAAzB,CAA+BmB,GAA/B,CADT,CAIOiC,eAAA,CAAgBpD,IAAhB,CAAsBmB,GAAAuB,IAAtB,CAA+BvB,GAAAlB,SAA/B,CAA6CkB,GAAAhB,kBAA7C,CAAoE,CAAC,CAACgB,GAAAmH,QAAtE,CAAA7H,KAAA,CAAwF,QAAS,CAAC8E,cAAD,CAAiB,CACvH,GAAuB,IAAvB,GAAIA,cAAJ,CACE,MAAOA,eACF,IAAIpE,GAAAmH,QAAJ,EAAmB,CAACnH,GAAAoH,OAApB,CAAgC,CACrC,GAA8B,QAA9B;AAAI,MAAOhD,eAAX,CACE,KAAU/C,MAAJ,CAAU,kDAAV,CAAN,CAEF,MAAOL,eAAA,CAAeoD,cAAf,CAJ8B,CAKhC,GAAIpE,GAAAmH,QAAJ,EAAmBnH,GAAAoH,OAAnB,CAA+B,CACpC,GAA8B,QAA9B,GAAI,MAAOhD,eAAX,CACE,KAAU/C,MAAJ,CAAU,kDAAV,CAAN,CAEF,MAAO8C,8BAAA,CAA8BtF,IAA9B,CAAoCuF,cAApC,CAAoDpE,GAAAuB,IAApD,CAA6DvB,GAAAlB,SAA7D,CAA2EkB,GAAAhB,kBAA3E,CAJ6B,CAK/B,GAAKgB,GAAAoH,OAAL,EAAoBpH,GAAAmH,QAApB,CAGL,KAAU9F,MAAJ,CAAU,wBAAV,CAAN,CAFA,MAAO+C,eAd8G,CAAlH,CAjBuB,CAzRhC1F,QAAA8I,QAAA,CA4UAA,QAAgB,CAAC3I,IAAD,CAAOiB,OAAP,CAAgBC,OAAhB,CAAyB,CAOvC,IAAIC,IAAMC,MAAAC,OAAA,CAAc,EAAd;AANKC,CACbsH,QAAS,CAAA,CADItH,CAEbuH,KAAM,CAAA,CAFOvH,CAGbwC,YAAa,EAHAxC,CAML,CAA4BJ,OAA5B,CAAV,CAEI4C,YAAc3C,GAAA2C,YAEbA,YAAL,GACEA,WADF,CACmC,QAAnB,GAAA,MAAO7C,QAAP,CAA8B,8BAA9B,CAA4D,0BAD5E,CAQA,KAAIM,UADAC,OACAD,CADa,EAEbJ,IAAA0H,KAAJ,GAEIrH,OAFJ,CAC0B,QAAxB,GAAI,MAAOL,IAAA0H,KAAX,CACe1H,GAAA0H,KADf,CAGe,CAAC,CAAA,CAAGpH,KAAAC,aAAJ,GAAAC,cAJjB,CAOIR,IAAAyH,QAAJ,GAC6B,QAA3B,GAAI,MAAOzH,IAAAyH,QAAX,CACErH,SADF,CACcJ,GAAAyH,QADd,EAGOpH,OAGL,GAFEA,OAEF,CAFe,CAAC,CAAA,CAAGC,KAAAC,aAAJ,GAAAC,cAEf,EAAAJ,SAAA,CAAY,CAAC,CAAA,CAAGK,KAAAC,wBAAJ,EAAmCL,OAAnC,CANd,CADF,CAcA,IAAI,CAACL,GAAAyH,QAAL;AAAoBzH,GAAA0H,KAApB,CAA8B,CACxBC,OAAAA,CAAkB,CAAC,CAAA,CAAG/G,WAAAgH,UAAJ,EAA2BvH,OAA3B,CAAuCP,OAAvC,CACtB,KAAI+H,iBAAmB/G,IAAAC,UAAA,CAAe4G,OAAf,CACvB,OAAO,CAAC,CAAA,CAAGjG,IAAAC,+BAAJ,GAAArC,KAAA,CAAgD,QAAS,CAACsC,aAAD,CAAgB,CAC9E,MAAO,KAAIJ,OAAJ,CAAY,QAAS,CAACC,OAAD,CAAUW,MAAV,CAAkB,CAC5C,MAAOZ,QAAA0B,IAAA,CAAY,CAAC,CAAC,CAAA,CAAGxB,IAAAuE,gBAAJ,EAA0BpH,IAA1B,CAAgCiB,OAAhC,CAAyC8B,aAAzC,CAAwDe,WAAxD,CAAD,CAAuE,CAAC,CAAA,CAAGjB,IAAAuE,gBAAJ,EAA0B,EAA1B,CAA+BpH,IAA/B,CAAsCsE,qBAAtC,CAA6D0E,gBAA7D,CAA+EjG,aAA/E,CAA8F,kBAA9F,CAAvE,CAAZ,CAAAtC,KAAA,CAA4MmC,OAA5M,CAAAqG,MAAA,CAA2N,QAAS,EAAG,CAC5O,CAAC,CAAA,CAAGpG,IAAAqG,0BAAJ,GAAAzI,KAAA,CAA2C,QAAS,CAAC0I,cAAD,CAAiB,CACnE,MAAOxG,QAAA0B,IAAA,CAAY,CAAC,CAAC,CAAA;AAAGxB,IAAAuE,gBAAJ,EAA0BpH,IAA1B,CAAgCiB,OAAhC,CAAyCkI,cAAzC,CAAyDrF,WAAzD,CAAD,CAAwE,CAAC,CAAA,CAAGjB,IAAAuE,gBAAJ,EAA0B,EAA1B,CAA+BpH,IAA/B,CAAsCsE,qBAAtC,CAA6D0E,gBAA7D,CAA+EG,cAA/E,CAA+F,kBAA/F,CAAxE,CAAZ,CAAA1I,KAAA,CAA8MmC,OAA9M,CAAAqG,MAAA,CAA6N1F,MAA7N,CAD4D,CAArE,CAD4O,CAAvO,CADqC,CAAvC,CADuE,CAAzE,CAAA9C,KAAA,CAQC,QAAS,CAAC2I,QAAD,CAAW,CAC1B,MAAOA,SAAA,CAAS,CAAT,CADmB,CARrB,CAHqB,CAiB1BjI,GAAAyH,QAAJ,EAAmB,CAACzH,GAAA0H,KAApB,EACE5H,OACA,CADUD,cAAA,CAAeC,OAAf,CAAwB,CAAEM,UAAWA,SAAb,CAAxB,CACV,CAAAuC,WAAA,CAAc,kBAFhB,EAGW3C,GAAAyH,QAHX,EAG0BzH,GAAA0H,KAH1B,GAIMjD,GAQJ,CARiB5E,cAAA,CAAeC,OAAf,CAAwB,CAAEM,UAAWA,SAAb,CAAxB,CAQjB,CAPI8H,OAOJ,CAPuB,CAAC,CAAA,CAAGtH,WAAAgH,UAAJ,EAA2BvH,OAA3B,CAAuCoE,GAAvC,CAOvB,CADA3E,OACA,CADUgB,IAAAC,UAAA,CALeoH,CACvBvE,UAAWsE,OAAAtE,UADYuE;AAEvB/H,UAAW8H,OAAA9H,UAFY+H,CAGvB1D,WAAYA,GAHW0D,CAKf,CACV,CAAAxF,WAAA,CAAc,kBAZhB,CAcA,OAAO,CAAC,CAAA,CAAGjB,IAAAC,+BAAJ,GAAArC,KAAA,CAAgD,QAAS,CAACsC,aAAD,CAAgB,CAC9E,MAAO,KAAIJ,OAAJ,CAAY,QAAS,CAACC,OAAD,CAAUW,MAAV,CAAkB,CAC5C,CAAC,CAAA,CAAGV,IAAAuE,gBAAJ,EAA0BpH,IAA1B,CAAgCiB,OAAhC,CAAyC8B,aAAzC,CAAwDe,WAAxD,CAAArD,KAAA,CAA0EmC,OAA1E,CAAAqG,MAAA,CAAyF,QAAS,EAAG,CACnG,CAAC,CAAA,CAAGpG,IAAAqG,0BAAJ,GAAAzI,KAAA,CAA2C,QAAS,CAAC0I,cAAD,CAAiB,CACnE,MAAO,CAAC,CAAA,CAAGtG,IAAAuE,gBAAJ,EAA0BpH,IAA1B,CAAgCiB,OAAhC,CAAyCkI,cAAzC,CAAyDrF,WAAzD,CAAArD,KAAA,CAA2EmC,OAA3E,CAAAqG,MAAA,CAA0F1F,MAA1F,CAD4D,CAArE,CADmG,CAArG,CAD4C,CAAvC,CADuE,CAAzE,CAxEgC,CA3UzC1D,QAAA0J,gBAAA,CAqaAA,QAAwB,CAACC,UAAD;AAAa7H,aAAb,CAA4B,CAClD,MAAO,CAAC,CAAA,CAAGkB,IAAA4G,aAAJ,EAAuBD,UAAvB,CAAmC7H,aAAnC,CAD2C,CApapD9B,QAAA6J,WAAA,CA+aAA,QAAmB,CAAC1J,IAAD,CAAO,CACxB2C,OAAAY,OAAA,CAAmBf,KAAJ,CAAU,YAAV,CAAyBxC,IAAzB,CAAgC,6BAAhC,CAAf,CADwB,CA9a1BH,QAAA8J,UAAA,CAyfAA,QAAkB,CAACzD,QAAD,CAAW,CAC3B,MAAO,CAAC,CAAA,CAAGrD,IAAAC,+BAAJ,GAAArC,KAAA,CAAgD,QAAS,CAACsC,aAAD,CAAgB,CAC9E,MAAO8C,cAAA,CAAc9C,aAAd,CAA6B,IAA7B,CAAmC,CAAnC,CAAsC,CAAtC,CAAyCmD,QAAzC,CADuE,CAAzE,CADoB,CAvf7B,KAAIrD,KAAOlD,OAAA,CAAQ,gDAAR,CAAX,CAEIoC,YAAcpC,OAAA,CAAQ,+CAAR,CAFlB,CAII8B,MAAQ9B,OAAA,CAAQ,+CAAR,CAJZ;AAMIiC,MAAQjC,OAAA,CAAQ,yCAAR,CANZ,CAQIY,UAAYZ,OAAA,CAAQ,mDAAR,CARhB,CAUIkF,QAAUlF,OAAA,CAAQ,2CAAR,CAVd,CAYIgE,QAAUhE,OAAA,CAAQ,2CAAR,CAZd,CAcI2E,sBAAwB,MA+e5BzE,QAAAwH,iBAAA,CAA2BxE,IAAAwE,iBAC3BxH,QAAAuH,gBAAA,CAA0BvE,IAAAuE,gBAC1BvH,QAAAsH,0BAAA,CAAoCtE,IAAAsE,0BAnhB8F;",
"sources":["node_modules/blockstack/lib/storage/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$blockstack$lib$storage$index\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BLOCKSTACK_GAIA_HUB_LABEL = exports.uploadToGaiaHub = exports.connectToGaiaHub = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n// export { type GaiaHubConfig } from './hub'\n\nexports.getUserAppFileUrl = getUserAppFileUrl;\nexports.encryptContent = encryptContent;\nexports.decryptContent = decryptContent;\nexports.getFile = getFile;\nexports.putFile = putFile;\nexports.getAppBucketUrl = getAppBucketUrl;\nexports.deleteFile = deleteFile;\nexports.listFiles = listFiles;\n\nvar _hub = require('./hub');\n\nvar _encryption = require('../encryption');\n\nvar _auth = require('../auth');\n\nvar _keys = require('../keys');\n\nvar _profiles = require('../profiles');\n\nvar _errors = require('../errors');\n\nvar _logger = require('../logger');\n\nvar SIGNATURE_FILE_SUFFIX = '.sig';\n\n/**\n * Fetch the public read URL of a user file for the specified app.\n * @param {String} path - the path to the file to read\n * @param {String} username - The Blockstack ID of the user to look up\n * @param {String} appOrigin - The app origin\n * @param {String} [zoneFileLookupURL=null] - The URL\n * to use for zonefile lookup. If falsey, this will use the\n * blockstack.js's getNameInfo function instead.\n * @return {Promise} that resolves to the public read URL of the file\n * or rejects with an error\n */\nfunction getUserAppFileUrl(path, username, appOrigin) {\n  var zoneFileLookupURL = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  return (0, _profiles.lookupProfile)(username, zoneFileLookupURL).then(function (profile) {\n    if (profile.hasOwnProperty('apps')) {\n      if (profile.apps.hasOwnProperty(appOrigin)) {\n        return profile.apps[appOrigin];\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }).then(function (bucketUrl) {\n    if (bucketUrl) {\n      var bucket = bucketUrl.replace(/\\/?(\\?|#|$)/, '/$1');\n      return '' + bucket + path;\n    } else {\n      return null;\n    }\n  });\n}\n\n/**\n * Encrypts the data provided with the app public key.\n * @param {String|Buffer} content - data to encrypt\n * @param {Object} [options=null] - options object\n * @param {String} options.publicKey - the hex string of the ECDSA public\n * key to use for encryption. If not provided, will use user's appPrivateKey.\n * @return {String} Stringified ciphertext object\n */\nfunction encryptContent(content, options) {\n  var defaults = { publicKey: null };\n  var opt = Object.assign({}, defaults, options);\n  if (!opt.publicKey) {\n    var privateKey = (0, _auth.loadUserData)().appPrivateKey;\n    opt.publicKey = (0, _keys.getPublicKeyFromPrivate)(privateKey);\n  }\n\n  var cipherObject = (0, _encryption.encryptECIES)(opt.publicKey, content);\n  return JSON.stringify(cipherObject);\n}\n\n/**\n * Decrypts data encrypted with `encryptContent` with the\n * transit private key.\n * @param {String|Buffer} content - encrypted content.\n * @param {Object} [options=null] - options object\n * @param {String} options.privateKey - the hex string of the ECDSA private\n * key to use for decryption. If not provided, will use user's appPrivateKey.\n * @return {String|Buffer} decrypted content.\n */\nfunction decryptContent(content, options) {\n  var defaults = { privateKey: null };\n  var opt = Object.assign({}, defaults, options);\n  var privateKey = opt.privateKey;\n  if (!privateKey) {\n    privateKey = (0, _auth.loadUserData)().appPrivateKey;\n  }\n\n  try {\n    var cipherObject = JSON.parse(content);\n    return (0, _encryption.decryptECIES)(privateKey, cipherObject);\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      throw new Error('Failed to parse encrypted content JSON. The content may not ' + 'be encrypted. If using getFile, try passing { decrypt: false }.');\n    } else {\n      throw err;\n    }\n  }\n}\n\n/* Get the gaia address used for servicing multiplayer reads for the given\n * (username, app) pair.\n * @private\n */\nfunction getGaiaAddress(app, username, zoneFileLookupURL) {\n  return Promise.resolve().then(function () {\n    if (username) {\n      return getUserAppFileUrl('/', username, app, zoneFileLookupURL);\n    } else {\n      return (0, _hub.getOrSetLocalGaiaHubConnection)().then(function (gaiaHubConfig) {\n        return (0, _hub.getFullReadUrl)('/', gaiaHubConfig);\n      });\n    }\n  }).then(function (fileUrl) {\n    var matches = fileUrl.match(/([13][a-km-zA-HJ-NP-Z0-9]{26,35})/);\n    if (!matches) {\n      throw new Error('Failed to parse gaia address');\n    }\n    return matches[matches.length - 1];\n  });\n}\n\n/* Handle fetching the contents from a given path. Handles both\n *  multi-player reads and reads from own storage.\n * @private\n */\nfunction getFileContents(path, app, username, zoneFileLookupURL, forceText) {\n  return Promise.resolve().then(function () {\n    if (username) {\n      return getUserAppFileUrl(path, username, app, zoneFileLookupURL);\n    } else {\n      return (0, _hub.getOrSetLocalGaiaHubConnection)().then(function (gaiaHubConfig) {\n        return (0, _hub.getFullReadUrl)(path, gaiaHubConfig);\n      });\n    }\n  }).then(function (readUrl) {\n    return new Promise(function (resolve, reject) {\n      if (!readUrl) {\n        reject(null);\n      } else {\n        resolve(readUrl);\n      }\n    });\n  }).then(function (readUrl) {\n    return fetch(readUrl);\n  }).then(function (response) {\n    if (response.status !== 200) {\n      if (response.status === 404) {\n        _logger.Logger.debug('getFile ' + path + ' returned 404, returning null');\n        return null;\n      } else {\n        throw new Error('getFile ' + path + ' failed with HTTP status ' + response.status);\n      }\n    }\n    var contentType = response.headers.get('Content-Type');\n    if (forceText || contentType === null || contentType.startsWith('text') || contentType === 'application/json') {\n      return response.text();\n    } else {\n      return response.arrayBuffer();\n    }\n  });\n}\n\n/* Handle fetching an unencrypted file, its associated signature\n *  and then validate it. Handles both multi-player reads and reads\n *  from own storage.\n * @private\n */\nfunction getFileSignedUnencrypted(path, opt) {\n  // future optimization note:\n  //    in the case of _multi-player_ reads, this does a lot of excess\n  //    profile lookups to figure out where to read files\n  //    do browsers cache all these requests if Content-Cache is set?\n  return Promise.all([getFileContents(path, opt.app, opt.username, opt.zoneFileLookupURL, false), getFileContents('' + path + SIGNATURE_FILE_SUFFIX, opt.app, opt.username, opt.zoneFileLookupURL, true), getGaiaAddress(opt.app, opt.username, opt.zoneFileLookupURL)]).then(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 3),\n        fileContents = _ref2[0],\n        signatureContents = _ref2[1],\n        gaiaAddress = _ref2[2];\n\n    if (!fileContents) {\n      return fileContents;\n    }\n    if (!gaiaAddress) {\n      throw new _errors.SignatureVerificationError('Failed to get gaia address for verification of: ' + ('' + path));\n    }\n    if (!signatureContents || typeof signatureContents !== 'string') {\n      throw new _errors.SignatureVerificationError('Failed to obtain signature for file: ' + (path + ' -- looked in ' + path + SIGNATURE_FILE_SUFFIX));\n    }\n    var signature = void 0;\n    var publicKey = void 0;\n    try {\n      var sigObject = JSON.parse(signatureContents);\n      signature = sigObject.signature;\n      publicKey = sigObject.publicKey;\n    } catch (err) {\n      if (err instanceof SyntaxError) {\n        throw new Error('Failed to parse signature content JSON ' + ('(path: ' + path + SIGNATURE_FILE_SUFFIX + ')') + ' The content may be corrupted.');\n      } else {\n        throw err;\n      }\n    }\n    var signerAddress = (0, _keys.publicKeyToAddress)(publicKey);\n    if (gaiaAddress !== signerAddress) {\n      throw new _errors.SignatureVerificationError('Signer pubkey address (' + signerAddress + ') doesn\\'t' + (' match gaia address (' + gaiaAddress + ')'));\n    } else if (!(0, _encryption.verifyECDSA)(Buffer.from(fileContents), publicKey, signature)) {\n      throw new _errors.SignatureVerificationError('Contents do not match ECDSA signature: ' + ('path: ' + path + ', signature: ' + path + SIGNATURE_FILE_SUFFIX));\n    } else {\n      return fileContents;\n    }\n  });\n}\n\n/* Handle signature verification and decryption for contents which are\n *  expected to be signed and encrypted. This works for single and\n *  multiplayer reads. In the case of multiplayer reads, it uses the\n *  gaia address for verification of the claimed public key.\n * @private\n */\nfunction handleSignedEncryptedContents(path, storedContents, app, username, zoneFileLookupURL) {\n  var appPrivateKey = (0, _auth.loadUserData)().appPrivateKey;\n  var appPublicKey = (0, _keys.getPublicKeyFromPrivate)(appPrivateKey);\n\n  var addressPromise = void 0;\n  if (username) {\n    addressPromise = getGaiaAddress(app, username, zoneFileLookupURL);\n  } else {\n    var address = (0, _keys.publicKeyToAddress)(appPublicKey);\n    addressPromise = Promise.resolve(address);\n  }\n\n  return addressPromise.then(function (address) {\n    if (!address) {\n      throw new _errors.SignatureVerificationError('Failed to get gaia address for verification of: ' + ('' + path));\n    }\n    var sigObject = void 0;\n    try {\n      sigObject = JSON.parse(storedContents);\n    } catch (err) {\n      if (err instanceof SyntaxError) {\n        throw new Error('Failed to parse encrypted, signed content JSON. The content may not ' + 'be encrypted. If using getFile, try passing' + ' { verify: false, decrypt: false }.');\n      } else {\n        throw err;\n      }\n    }\n    var signature = sigObject.signature;\n    var signerPublicKey = sigObject.publicKey;\n    var cipherText = sigObject.cipherText;\n    var signerAddress = (0, _keys.publicKeyToAddress)(signerPublicKey);\n\n    if (!signerPublicKey || !cipherText || !signature) {\n      throw new _errors.SignatureVerificationError('Failed to get signature verification data from file:' + (' ' + path));\n    } else if (signerAddress !== address) {\n      throw new _errors.SignatureVerificationError('Signer pubkey address (' + signerAddress + ') doesn\\'t' + (' match gaia address (' + address + ')'));\n    } else if (!(0, _encryption.verifyECDSA)(cipherText, signerPublicKey, signature)) {\n      throw new _errors.SignatureVerificationError('Contents do not match ECDSA signature in file:' + (' ' + path));\n    } else {\n      return decryptContent(cipherText);\n    }\n  });\n}\n\n/**\n * Retrieves the specified file from the app's data store.\n * @param {String} path - the path to the file to read\n * @param {Object} [options=null] - options object\n * @param {Boolean} [options.decrypt=true] - try to decrypt the data with the app private key\n * @param {String} options.username - the Blockstack ID to lookup for multi-player storage\n * @param {Boolean} options.verify - Whether the content should be verified, only to be used\n * when `putFile` was set to `sign = true`\n * @param {String} options.app - the app to lookup for multi-player storage -\n * defaults to current origin\n * @param {String} [options.zoneFileLookupURL=null] - The URL\n * to use for zonefile lookup. If falsey, this will use the\n * blockstack.js's getNameInfo function instead.\n * @returns {Promise} that resolves to the raw data in the file\n * or rejects with an error\n */\nfunction getFile(path, options) {\n  var defaults = {\n    decrypt: true,\n    verify: false,\n    username: null,\n    app: window.location.origin,\n    zoneFileLookupURL: null\n  };\n\n  var opt = Object.assign({}, defaults, options);\n\n  // in the case of signature verification, but no\n  //  encryption expected, need to fetch _two_ files.\n  if (opt.verify && !opt.decrypt) {\n    return getFileSignedUnencrypted(path, opt);\n  }\n\n  return getFileContents(path, opt.app, opt.username, opt.zoneFileLookupURL, !!opt.decrypt).then(function (storedContents) {\n    if (storedContents === null) {\n      return storedContents;\n    } else if (opt.decrypt && !opt.verify) {\n      if (typeof storedContents !== 'string') {\n        throw new Error('Expected to get back a string for the cipherText');\n      }\n      return decryptContent(storedContents);\n    } else if (opt.decrypt && opt.verify) {\n      if (typeof storedContents !== 'string') {\n        throw new Error('Expected to get back a string for the cipherText');\n      }\n      return handleSignedEncryptedContents(path, storedContents, opt.app, opt.username, opt.zoneFileLookupURL);\n    } else if (!opt.verify && !opt.decrypt) {\n      return storedContents;\n    } else {\n      throw new Error('Should be unreachable.');\n    }\n  });\n}\n\n/**\n * Stores the data provided in the app's data store to to the file specified.\n * @param {String} path - the path to store the data in\n * @param {String|Buffer} content - the data to store in the file\n * @param {Object} [options=null] - options object\n * @param {Boolean|String} [options.encrypt=true] - encrypt the data with the app private key\n *                                                  or the provided public key\n * @param {Boolean} [options.sign=false] - sign the data using ECDSA on SHA256 hashes with\n *                                         the app private key\n * @param {String} [options.contentType=''] - set a Content-Type header for unencrypted data\n * @return {Promise} that resolves if the operation succeed and rejects\n * if it failed\n */\nfunction putFile(path, content, options) {\n  var defaults = {\n    encrypt: true,\n    sign: false,\n    contentType: ''\n  };\n\n  var opt = Object.assign({}, defaults, options);\n\n  var contentType = opt.contentType;\n\n  if (!contentType) {\n    contentType = typeof content === 'string' ? 'text/plain; charset=utf-8' : 'application/octet-stream';\n  }\n\n  // First, let's figure out if we need to get public/private keys,\n  //  or if they were passed in\n\n  var privateKey = '';\n  var publicKey = '';\n  if (opt.sign) {\n    if (typeof opt.sign === 'string') {\n      privateKey = opt.sign;\n    } else {\n      privateKey = (0, _auth.loadUserData)().appPrivateKey;\n    }\n  }\n  if (opt.encrypt) {\n    if (typeof opt.encrypt === 'string') {\n      publicKey = opt.encrypt;\n    } else {\n      if (!privateKey) {\n        privateKey = (0, _auth.loadUserData)().appPrivateKey;\n      }\n      publicKey = (0, _keys.getPublicKeyFromPrivate)(privateKey);\n    }\n  }\n\n  // In the case of signing, but *not* encrypting,\n  //   we perform two uploads. So the control-flow\n  //   here will return there.\n  if (!opt.encrypt && opt.sign) {\n    var signatureObject = (0, _encryption.signECDSA)(privateKey, content);\n    var signatureContent = JSON.stringify(signatureObject);\n    return (0, _hub.getOrSetLocalGaiaHubConnection)().then(function (gaiaHubConfig) {\n      return new Promise(function (resolve, reject) {\n        return Promise.all([(0, _hub.uploadToGaiaHub)(path, content, gaiaHubConfig, contentType), (0, _hub.uploadToGaiaHub)('' + path + SIGNATURE_FILE_SUFFIX, signatureContent, gaiaHubConfig, 'application/json')]).then(resolve).catch(function () {\n          (0, _hub.setLocalGaiaHubConnection)().then(function (freshHubConfig) {\n            return Promise.all([(0, _hub.uploadToGaiaHub)(path, content, freshHubConfig, contentType), (0, _hub.uploadToGaiaHub)('' + path + SIGNATURE_FILE_SUFFIX, signatureContent, freshHubConfig, 'application/json')]).then(resolve).catch(reject);\n          });\n        });\n      });\n    }).then(function (fileUrls) {\n      return fileUrls[0];\n    });\n  }\n\n  // In all other cases, we only need one upload.\n  if (opt.encrypt && !opt.sign) {\n    content = encryptContent(content, { publicKey: publicKey });\n    contentType = 'application/json';\n  } else if (opt.encrypt && opt.sign) {\n    var cipherText = encryptContent(content, { publicKey: publicKey });\n    var _signatureObject = (0, _encryption.signECDSA)(privateKey, cipherText);\n    var signedCipherObject = {\n      signature: _signatureObject.signature,\n      publicKey: _signatureObject.publicKey,\n      cipherText: cipherText\n    };\n    content = JSON.stringify(signedCipherObject);\n    contentType = 'application/json';\n  }\n  return (0, _hub.getOrSetLocalGaiaHubConnection)().then(function (gaiaHubConfig) {\n    return new Promise(function (resolve, reject) {\n      (0, _hub.uploadToGaiaHub)(path, content, gaiaHubConfig, contentType).then(resolve).catch(function () {\n        (0, _hub.setLocalGaiaHubConnection)().then(function (freshHubConfig) {\n          return (0, _hub.uploadToGaiaHub)(path, content, freshHubConfig, contentType).then(resolve).catch(reject);\n        });\n      });\n    });\n  });\n}\n\n/**\n * Get the app storage bucket URL\n * @param {String} gaiaHubUrl - the gaia hub URL\n * @param {String} appPrivateKey - the app private key used to generate the app address\n * @returns {Promise} That resolves to the URL of the app index file\n * or rejects if it fails\n */\nfunction getAppBucketUrl(gaiaHubUrl, appPrivateKey) {\n  return (0, _hub.getBucketUrl)(gaiaHubUrl, appPrivateKey);\n}\n\n/**\n * Deletes the specified file from the app's data store. Currently not implemented.\n * @param {String} path - the path to the file to delete\n * @returns {Promise} that resolves when the file has been removed\n * or rejects with an error\n * @private\n */\nfunction deleteFile(path) {\n  Promise.reject(new Error('Delete of ' + path + ' not supported by gaia hubs'));\n}\n\n/**\n * Loop over the list of files in a Gaia hub, and run a callback on each entry.\n * Not meant to be called by external clients.\n * @param {GaiaHubConfig} hubConfig - the Gaia hub config\n * @param {String | null} page - the page ID\n * @param {number} callCount - the loop count\n * @param {number} fileCount - the number of files listed so far\n * @param {function} callback - the callback to invoke on each file.  If it returns a falsey\n *  value, then the loop stops.  If it returns a truthy value, the loop continues.\n * @returns {Promise} that resolves to the number of files listed.\n * @private\n */\nfunction listFilesLoop(hubConfig, page, callCount, fileCount, callback) {\n  if (callCount > 65536) {\n    // this is ridiculously huge, and probably indicates\n    // a faulty Gaia hub anyway (e.g. on that serves endless data)\n    throw new Error('Too many entries to list');\n  }\n\n  var httpStatus = void 0;\n  var pageRequest = JSON.stringify({ page: page });\n\n  var fetchOptions = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Content-Length': '' + pageRequest.length,\n      Authorization: 'bearer ' + hubConfig.token\n    },\n    body: pageRequest\n  };\n\n  return fetch(hubConfig.server + '/list-files/' + hubConfig.address, fetchOptions).then(function (response) {\n    httpStatus = response.status;\n    if (httpStatus >= 400) {\n      throw new Error('listFiles failed with HTTP status ' + httpStatus);\n    }\n    return response.text();\n  }).then(function (responseText) {\n    return JSON.parse(responseText);\n  }).then(function (responseJSON) {\n    var entries = responseJSON.entries;\n    var nextPage = responseJSON.page;\n    if (entries === null || entries === undefined) {\n      // indicates a misbehaving Gaia hub or a misbehaving driver\n      // (i.e. the data is malformed)\n      throw new Error('Bad listFiles response: no entries');\n    }\n    for (var i = 0; i < entries.length; i++) {\n      var rc = callback(entries[i]);\n      if (!rc) {\n        // callback indicates that we're done\n        return Promise.resolve(fileCount + i);\n      }\n    }\n    if (nextPage && entries.length > 0) {\n      // keep going -- have more entries\n      return listFilesLoop(hubConfig, nextPage, callCount + 1, fileCount + entries.length, callback);\n    } else {\n      // no more entries -- end of data\n      return Promise.resolve(fileCount + entries.length);\n    }\n  });\n}\n\n/**\n * List the set of files in this application's Gaia storage bucket.\n * @param {function} callback - a callback to invoke on each named file that\n * returns `true` to continue the listing operation or `false` to end it\n * @return {Promise} that resolves to the number of files listed\n */\nfunction listFiles(callback) {\n  return (0, _hub.getOrSetLocalGaiaHubConnection)().then(function (gaiaHubConfig) {\n    return listFilesLoop(gaiaHubConfig, null, 0, 0, callback);\n  });\n}\n\nexports.connectToGaiaHub = _hub.connectToGaiaHub;\nexports.uploadToGaiaHub = _hub.uploadToGaiaHub;\nexports.BLOCKSTACK_GAIA_HUB_LABEL = _hub.BLOCKSTACK_GAIA_HUB_LABEL;\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","getUserAppFileUrl","path","username","appOrigin","zoneFileLookupURL","arguments","length","undefined","_profiles","lookupProfile","then","profile","hasOwnProperty","apps","bucketUrl","replace","bucket","encryptContent","content","options","opt","Object","assign","defaults","publicKey","privateKey","_auth","loadUserData","appPrivateKey","_keys","getPublicKeyFromPrivate","cipherObject","_encryption","encryptECIES","JSON","stringify","decryptContent","parse","decryptECIES","err","SyntaxError","Error","getGaiaAddress","app","Promise","resolve","_hub","getOrSetLocalGaiaHubConnection","gaiaHubConfig","getFullReadUrl","fileUrl","matches","match","getFileContents","forceText","readUrl","reject","fetch","response","status","_logger","Logger","debug","contentType","headers","get","startsWith","text","arrayBuffer","getFileSignedUnencrypted","all","SIGNATURE_FILE_SUFFIX","_ref","_ref2","_slicedToArray","fileContents","signatureContents","gaiaAddress","_errors","SignatureVerificationError","signature","sigObject","signerAddress","publicKeyToAddress","verifyECDSA","Buffer","from","handleSignedEncryptedContents","storedContents","appPublicKey","addressPromise","address","signerPublicKey","cipherText","listFilesLoop","hubConfig","page","callCount","fileCount","callback","httpStatus","pageRequest","server","fetchOptions","method","Authorization","token","body","responseText","responseJSON","entries","nextPage","i","rc","defineProperty","value","BLOCKSTACK_GAIA_HUB_LABEL","uploadToGaiaHub","connectToGaiaHub","arr","Array","isArray","Symbol","iterator","_arr","_n","_d","_e","_i","_s","done","next","push","TypeError","getFile","decrypt","verify","window","location","origin","putFile","encrypt","sign","signatureObject","signECDSA","signatureContent","catch","setLocalGaiaHubConnection","freshHubConfig","fileUrls","_signatureObject","signedCipherObject","getAppBucketUrl","gaiaHubUrl","getBucketUrl","deleteFile","listFiles"]
}
