{
"version":3,
"file":"module$node_modules$bip32$index.js",
"lineCount":12,
"mappings":"AAAAA,cAAA,gCAAA,CAAoD,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,OAAhB,CAAwBC,MAAxB,CAA+BC,OAA/B,CAAuCC,YAAvC,CAAqD,CAyBjHC,QAASA,MAAM,CAACC,CAAD,CAAIC,CAAJ,CAAOC,SAAP,CAAkBC,OAAlB,CAA2B,CACxCC,SAAA,CAAUC,YAAV,CAAwBF,OAAxB,CAEA,KAAAG,IAAA,CAAWN,CAAX,EAAgB,IAChB,KAAAO,IAAA,CAAWN,CAAX,EAAgB,IAEhB,KAAAC,UAAA,CAAiBA,SAEjB,KAAAM,MAAA,CADA,IAAAC,MACA,CADa,CAEb,KAAAN,QAAA,CAAeA,OACf,KAAAO,kBAAA,CAAyB,CAVe,CA8I1CC,QAASA,OAAO,CAACC,KAAD,CAAQ,CACtB,MAAOR,UAAAS,OAAA,CAAiBD,KAAjB,CAAP,EAAkCA,KAAlC,EAA2CE,UADrB,CAWxBC,QAASA,UAAU,CAACH,KAAD,CAAQ,CACzB,MAAOR,UAAAY,OAAA,CAAiBJ,KAAjB,CAAP,EAAkCA,KAAAK,MAAA,CAAY,yBAAZ,CADT,CAkF3BC,QAASA,eAAe,CAACC,UAAD;AAAajB,SAAb,CAAwBC,OAAxB,CAAiC,CACvDC,SAAA,CAAU,CACRe,WAAYC,YADJ,CAERlB,UAAWkB,YAFH,CAAV,CAGG,CAAED,WAAAA,UAAF,CAAcjB,UAAAA,SAAd,CAHH,CAIAC,QAAA,CAAUA,OAAV,EAAqBkB,OAErB,IAAI,CAACC,GAAAC,UAAA,CAAcJ,UAAd,CAAL,CAAgC,KAAM,KAAIK,SAAJ,CAAc,iCAAd,CAAN,CAChC,MAAO,KAAIzB,KAAJ,CAAUoB,UAAV,CAAsB,IAAtB,CAA4BjB,SAA5B,CAAuCC,OAAvC,CARgD,CAWzDsB,QAASA,cAAc,CAACC,SAAD,CAAYxB,SAAZ,CAAuBC,OAAvB,CAAgC,CACrDC,SAAA,CAAU,CACRsB,UAAWtB,SAAAuB,QAAA,CAAkB,EAAlB,CADH,CAERzB,UAAWkB,YAFH,CAAV,CAGG,CAAEM,UAAAA,SAAF,CAAaxB,UAAAA,SAAb,CAHH,CAIAC,QAAA,CAAUA,OAAV,EAAqBkB,OAGrB,IAAI,CAACC,GAAAM,QAAA,CAAYF,SAAZ,CAAL,CAA6B,KAAM,KAAIF,SAAJ,CAAc,2BAAd,CAAN;AAC7B,MAAO,KAAIzB,KAAJ,CAAU,IAAV,CAAgB2B,SAAhB,CAA2BxB,SAA3B,CAAsCC,OAAtC,CAT8C,CA9QvD,IAAI0B,OAASlC,OAAA,CAAQ,uCAAR,CAAAkC,OAAb,CACIC,UAAYnC,OAAA,CAAQ,qCAAR,CADhB,CAEIoC,OAASpC,OAAA,CAAQ,kCAAR,CAFb,CAGI2B,IAAM3B,OAAA,CAAQ,2CAAR,CAHV,CAIIS,UAAYT,OAAA,CAAQ,qCAAR,CAJhB,CAKIqC,IAAMrC,OAAA,CAAQ,+BAAR,CALV,CAOIyB,aAAehB,SAAAuB,QAAA,CAAkB,EAAlB,CAPnB,CAQItB,aAAeD,SAAA6B,QAAA,CAAkB,CACnCD,IAAK5B,SAAA8B,MAD8B,CAEnCC,MAAO,CACLC,OAAQhC,SAAAS,OADH;AAELwB,QAASjC,SAAAS,OAFJ,CAF4B,CAAlB,CARnB,CAgBIQ,QAAU,CACZW,IAAK,GADO,CAEZG,MAAO,CACLC,OAAQ,QADH,CAELC,QAAS,QAFJ,CAFK,CAqBdC,OAAAC,eAAA,CAAsBxC,KAAAyC,UAAtB,CAAuC,YAAvC,CAAqD,CAAEC,IAAKA,QAAS,EAAG,CAAE,MAAOV,OAAAW,QAAA,CAAe,IAAAhB,UAAf,CAAT,CAAnB,CAArD,CACAY,OAAAC,eAAA,CAAsBxC,KAAAyC,UAAtB,CAAuC,aAAvC,CAAsD,CAAEC,IAAKA,QAAS,EAAG,CAAE,MAAO,KAAAE,WAAAC,MAAA,CAAsB,CAAtB,CAAyB,CAAzB,CAAT,CAAnB,CAAtD,CACAN,OAAAC,eAAA,CAAsBxC,KAAAyC,UAAtB,CAAuC,YAAvC,CAAqD,CACnDK,WAAY,CAAA,CADuC,CAEnDJ,IAAKA,QAAS,EAAG,CAAE,MAAO,KAAAnC,IAAT,CAFkC,CAArD,CAIAgC,OAAAC,eAAA,CAAsBxC,KAAAyC,UAAtB,CAAuC,WAAvC,CAAoD,CAAEC,IAAKA,QAAS,EAAG,CAChE,IAAAlC,IAAL,GAAe,IAAAA,IAAf,CAA0Be,GAAAwB,gBAAA,CAAoB,IAAAxC,IAApB;AAA8B,IAAAyC,WAA9B,CAA1B,CACA,OAAO,KAAAxC,IAF8D,CAAnB,CAApD,CAOAR,MAAAyC,UAAAQ,WAAA,CAA6BC,QAAS,EAAG,CACvC,MAAoB,KAApB,GAAO,IAAA3C,IADgC,CAIzCP,MAAAyC,UAAAU,SAAA,CAA2BC,QAAS,EAAG,CACrC,IAAID,SAAWzB,aAAA,CAAc,IAAAC,UAAd,CAA8B,IAAAxB,UAA9B,CAA8C,IAAAC,QAA9C,CACf+C,SAAAzC,MAAA,CAAiB,IAAAA,MACjByC,SAAA1C,MAAA,CAAiB,IAAAA,MACjB0C,SAAAxC,kBAAA,CAA6B,IAAAA,kBAC7B,OAAOwC,SAL8B,CAQvCnD,MAAAyC,UAAAY,SAAA,CAA2BC,QAAS,EAAG,CACrC,IAAIlD,QAAU,IAAAA,QACVmD,QAAAA,CAAY,IAAAN,WAAA,EAAF,CAA+C7C,OAAAgC,MAAAC,OAA/C,CAAuBjC,OAAAgC,MAAAE,QACrC,KAAIkB,OAAS1B,MAAA2B,YAAA,CAAmB,EAAnB,CAGbD,OAAAE,cAAA,CAAqBH,OAArB;AAA8B,CAA9B,CAGAC,OAAAG,WAAA,CAAkB,IAAAjD,MAAlB,CAA8B,CAA9B,CAGA8C,OAAAE,cAAA,CAAqB,IAAA/C,kBAArB,CAA6C,CAA7C,CAIA6C,OAAAE,cAAA,CAAqB,IAAAjD,MAArB,CAAiC,CAAjC,CAGA,KAAAN,UAAAyD,KAAA,CAAoBJ,MAApB,CAA4B,EAA5B,CAGK,KAAAP,WAAA,EAAL,CAQE,IAAAtB,UAAAiC,KAAA,CAAoBJ,MAApB,CAA4B,EAA5B,CARF,EAEEA,MAAAG,WAAA,CAAkB,CAAlB,CAAqB,EAArB,CACA,CAAA,IAAAvC,WAAAwC,KAAA,CAAqBJ,MAArB,CAA6B,EAA7B,CAHF,CAWA,OAAOzB,UAAA8B,OAAA,CAAiBL,MAAjB,CAjC8B,CAoCvCxD,MAAAyC,UAAAqB,MAAA,CAAwBC,QAAS,EAAG,CAClC,GAAI,CAAC,IAAA3C,WAAL,CAAsB,KAAM,KAAIK,SAAJ,CAAc,qBAAd,CAAN,CACtB,MAAOQ,IAAA4B,OAAA,CAAW,IAAAzD,QAAA6B,IAAX,CAA6B,IAAAb,WAA7B,CAA8C,CAAA,CAA9C,CAF2B,CAQpCpB,MAAAyC,UAAAuB,OAAA,CAAyBC,QAAS,CAACxD,KAAD,CAAQ,CACxCJ,SAAA,CAAUA,SAAAS,OAAV;AAA4BL,KAA5B,CAEA,KAAIyD,WANYC,UAMZD,EAAazD,KAAjB,CACI2D,KAAOtC,MAAA2B,YAAA,CAAmB,EAAnB,CAGX,IAAIS,UAAJ,CAAgB,CACd,GAAI,IAAAjB,WAAA,EAAJ,CAAuB,KAAM,KAAIxB,SAAJ,CAAc,4CAAd,CAAN,CAGvB2C,IAAA,CAAK,CAAL,CAAA,CAAU,CACV,KAAAhD,WAAAwC,KAAA,CAAqBQ,IAArB,CAA2B,CAA3B,CALc,CAAhB,IAYE,KAAAzC,UAAAiC,KAAA,CAAoBQ,IAApB,CAA0B,CAA1B,CANAA,KAAAV,cAAA,CAAmBjD,KAAnB,CAA0B,EAA1B,CAUE4D,WAAAA,CAAIrC,MAAAsC,WAAA,CAAkB,IAAAnE,UAAlB,CAAkCiE,IAAlC,CACJG,KAAAA,CAAKF,UAAAxB,MAAA,CAAQ,CAAR,CAAW,EAAX,CACL2B,WAAAA,CAAKH,UAAAxB,MAAA,CAAQ,EAAR,CAGT,IAAI,CAACtB,GAAAC,UAAA,CAAc+C,IAAd,CAAL,CAAwB,MAAO,KAAAP,OAAA,CAAYvD,KAAZ,CAAoB,CAApB,CAI/B,IAAK,IAAAwC,WAAA,EAAL,CAUO,CAGDwB,IAAAA,CAAKlD,GAAAmD,eAAA,CAAmB,IAAA/C,UAAnB,CAAmC4C,IAAnC,CAAuC,CAAA,CAAvC,CAGT;GAAW,IAAX,GAAIE,IAAJ,CAAiB,MAAO,KAAAT,OAAA,CAAYvD,KAAZ,CAAoB,CAApB,CAExBkE,WAAA,CAAKjD,aAAA,CAAc+C,IAAd,CAAkBD,UAAlB,CAAsB,IAAApE,QAAtB,CARA,CAVP,IAAwB,CAElBwE,IAAAA,CAAKrD,GAAAsD,WAAA,CAAe,IAAAzD,WAAf,CAAgCmD,IAAhC,CAGT,IAAU,IAAV,EAAIK,IAAJ,CAAgB,MAAO,KAAAZ,OAAA,CAAYvD,KAAZ,CAAoB,CAApB,CAEvBkE,WAAA,CAAKxD,cAAA,CAAeyD,IAAf,CAAmBJ,UAAnB,CAAuB,IAAApE,QAAvB,CAPiB,CAqBxBuE,UAAAjE,MAAA,CAAW,IAAAA,MAAX,CAAwB,CACxBiE,WAAAlE,MAAA,CAAWA,KACXkE,WAAAhE,kBAAA,CAAuB,IAAAmE,YAAAC,aAAA,CAA8B,CAA9B,CACvB,OAAOJ,WAxDiC,CA2D1C,KAAI5D,WAAaiE,IAAAC,IAAA,CAAS,CAAT,CAAY,EAAZ,CAAblE,CAA+B,CAKnCf,MAAAyC,UAAAyC,eAAA,CAAiCC,QAAS,CAAC1E,KAAD,CAAQ,CAChDJ,SAAA,CAAUO,MAAV,CAAkBH,KAAlB,CAGA,OAAO,KAAAuD,OAAA,CAAYvD,KAAZ;AAvES0D,UAuET,CAJyC,CAWlDnE,MAAAyC,UAAA2C,WAAA,CAA6BC,QAAS,CAACC,IAAD,CAAO,CAC3CjF,SAAA,CAAUW,SAAV,CAAqBsE,IAArB,CAEIC,KAAAA,CAAYD,IAAAE,MAAA,CAAW,GAAX,CAChB,IAAqB,GAArB,GAAID,IAAA,CAAU,CAAV,CAAJ,CAA0B,CACxB,GAAI,IAAA5E,kBAAJ,CAA4B,KAAM,KAAIc,SAAJ,CAAc,4BAAd,CAAN,CAE5B8D,IAAA,CAAYA,IAAA1C,MAAA,CAAgB,CAAhB,CAHY,CAM1B,MAAO0C,KAAAE,OAAA,CAAiB,QAAS,CAACC,MAAD,CAASC,QAAT,CAAmB,CAElD,GAA2B,GAA3B,GAAIA,QAAA9C,MAAA,CAAgB,EAAhB,CAAJ,CAEE,MADApC,SACO,CADCmF,QAAA,CAASD,QAAA9C,MAAA,CAAe,CAAf,CAAmB,EAAnB,CAAT,CAAgC,EAAhC,CACD,CAAA6C,MAAAR,eAAA,CAAsBzE,QAAtB,CAEPA,SAAA,CAAQmF,QAAA,CAASD,QAAT,CAAmB,EAAnB,CACR,OAAOD,OAAA1B,OAAA,CAAcvD,QAAd,CAPyC,CAA7C,CASJ,IATI,CAVoC,CAsB7CT,MAAAyC,UAAAoD,KAAA,CAAuBC,QAAS,CAACC,IAAD,CAAO,CACrC,MAAOxE,IAAAsE,KAAA,CAASE,IAAT,CAAe,IAAA3E,WAAf,CAD8B,CAIvCpB;KAAAyC,UAAAuD,OAAA,CAAyBC,QAAS,CAACF,IAAD,CAAOG,SAAP,CAAkB,CAClD,MAAO3E,IAAAyE,OAAA,CAAWD,IAAX,CAAiB,IAAApE,UAAjB,CAAiCuE,SAAjC,CAD2C,CAwFpDrG,OAAAC,QAAA,CAAiB,CACfqG,WArFFA,QAAoB,CAACC,MAAD,CAAShG,OAAT,CAAkB,CACpC,IAAIoD,OAASzB,SAAAsE,OAAA,CAAiBD,MAAjB,CACb,IAAsB,EAAtB,GAAI5C,MAAA8C,OAAJ,CAA0B,KAAM,KAAI7E,SAAJ,CAAc,uBAAd,CAAN,CAC1BrB,OAAA,CAAUA,OAAV,EAAqBkB,OAGrB,KAAIiC,QAAUC,MAAAuB,aAAA,CAAoB,CAApB,CACd,IAAIxB,OAAJ,GAAgBnD,OAAAgC,MAAAE,QAAhB,EACEiB,OADF,GACcnD,OAAAgC,MAAAC,OADd,CACoC,KAAM,KAAIZ,SAAJ,CAAc,yBAAd,CAAN,CAGhCf,MAAAA,CAAQ8C,MAAA,CAAO,CAAP,CAGZ,KAAI7C,kBAAoB6C,MAAAuB,aAAA,CAAoB,CAApB,CACxB,IAAc,CAAd,GAAIrE,MAAJ;AAC4B,CAD5B,GACMC,iBADN,CACwC,KAAM,KAAIc,SAAJ,CAAc,4BAAd,CAAN,CAKxC,IAAIhB,MAAQ+C,MAAAuB,aAAA,CAAoB,CAApB,CACZ,IAAc,CAAd,GAAIrE,MAAJ,EAA6B,CAA7B,GAAmBD,KAAnB,CAAgC,KAAM,KAAIgB,SAAJ,CAAc,eAAd,CAAN,CAGhC,IAAItB,UAAYqD,MAAAX,MAAA,CAAa,EAAb,CAAiB,EAAjB,CAIhB,IAAIU,OAAJ,GAAgBnD,OAAAgC,MAAAE,QAAhB,CAAuC,CACrC,GAA6B,CAA7B,GAAIkB,MAAA+C,UAAA,CAAiB,EAAjB,CAAJ,CAAmC,KAAM,KAAI9E,SAAJ,CAAc,qBAAd,CAAN,CAC/B+E,MAAAA,CAAIhD,MAAAX,MAAA,CAAa,EAAb,CAAiB,EAAjB,CAER8B,QAAA,CAAKxD,cAAA,CAAeqF,MAAf,CAAkBrG,SAAlB,CAA6BC,OAA7B,CAJgC,CAAvC,IAQMqG,OAEJ,CAFQjD,MAAAX,MAAA,CAAa,EAAb,CAAiB,EAAjB,CAER,CAAA8B,OAAA,CAAKjD,aAAA,CAAc+E,MAAd,CAAiBtG,SAAjB,CAA4BC,OAA5B,CAGPuE,QAAAjE,MAAA,CAAWA,MACXiE,QAAAlE,MAAA,CAAWA,KACXkE;OAAAhE,kBAAA,CAAuBA,iBACvB,OAAOgE,QA7C6B,CAoFrB,CAEfxD,eAAAA,cAFe,CAGfO,cAAAA,aAHe,CAIfgF,SAjBFA,QAAkB,CAACC,IAAD,CAAOvG,OAAP,CAAgB,CAChCC,SAAA,CAAUA,SAAAyB,OAAV,CAA4B6E,IAA5B,CACA,IAAkB,EAAlB,CAAIA,IAAAL,OAAJ,CAAsB,KAAM,KAAI7E,SAAJ,CAAc,kCAAd,CAAN,CACtB,GAAkB,EAAlB,CAAIkF,IAAAL,OAAJ,CAAsB,KAAM,KAAI7E,SAAJ,CAAc,iCAAd,CAAN,CACtBrB,OAAA,CAAUA,OAAV,EAAqBkB,OAErB,KAAI+C,EAAIrC,MAAAsC,WAAA,CAAkB,cAAlB,CAAkCqC,IAAlC,CACJpC,KAAAA,CAAKF,CAAAxB,MAAA,CAAQ,CAAR,CAAW,EAAX,CACL2B,EAAAA,CAAKH,CAAAxB,MAAA,CAAQ,EAAR,CAET,OAAO1B,eAAA,CAAeoD,IAAf,CAAmBC,CAAnB,CAAuBpE,OAAvB,CAVyB,CAajB,CAxSgG;",
"sources":["node_modules/bip32/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$bip32$index\"] = function(global,process,require,module,exports,shadow$shims) {\nlet Buffer = require('safe-buffer').Buffer\nlet bs58check = require('bs58check')\nlet crypto = require('./crypto')\nlet ecc = require('tiny-secp256k1')\nlet typeforce = require('typeforce')\nlet wif = require('wif')\n\nlet UINT256_TYPE = typeforce.BufferN(32)\nlet NETWORK_TYPE = typeforce.compile({\n  wif: typeforce.UInt8,\n  bip32: {\n    public: typeforce.UInt32,\n    private: typeforce.UInt32\n  }\n})\n\nlet BITCOIN = {\n  wif: 0x80,\n  bip32: {\n    public: 0x0488b21e,\n    private: 0x0488ade4\n  }\n}\n\nfunction BIP32 (d, Q, chainCode, network) {\n  typeforce(NETWORK_TYPE, network)\n\n  this.__d = d || null\n  this.__Q = Q || null\n\n  this.chainCode = chainCode\n  this.depth = 0\n  this.index = 0\n  this.network = network\n  this.parentFingerprint = 0x00000000\n}\n\nObject.defineProperty(BIP32.prototype, 'identifier', { get: function () { return crypto.hash160(this.publicKey) } })\nObject.defineProperty(BIP32.prototype, 'fingerprint', { get: function () { return this.identifier.slice(0, 4) } })\nObject.defineProperty(BIP32.prototype, 'privateKey', {\n  enumerable: false,\n  get: function () { return this.__d }\n})\nObject.defineProperty(BIP32.prototype, 'publicKey', { get: function () {\n  if (!this.__Q) this.__Q = ecc.pointFromScalar(this.__d, this.compressed)\n  return this.__Q\n}})\n\n// Private === not neutered\n// Public === neutered\nBIP32.prototype.isNeutered = function () {\n  return this.__d === null\n}\n\nBIP32.prototype.neutered = function () {\n  let neutered = fromPublicKey(this.publicKey, this.chainCode, this.network)\n  neutered.depth = this.depth\n  neutered.index = this.index\n  neutered.parentFingerprint = this.parentFingerprint\n  return neutered\n}\n\nBIP32.prototype.toBase58 = function () {\n  let network = this.network\n  let version = (!this.isNeutered()) ? network.bip32.private : network.bip32.public\n  let buffer = Buffer.allocUnsafe(78)\n\n  // 4 bytes: version bytes\n  buffer.writeUInt32BE(version, 0)\n\n  // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....\n  buffer.writeUInt8(this.depth, 4)\n\n  // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n  buffer.writeUInt32BE(this.parentFingerprint, 5)\n\n  // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in big endian. (0x00000000 if master key)\n  buffer.writeUInt32BE(this.index, 9)\n\n  // 32 bytes: the chain code\n  this.chainCode.copy(buffer, 13)\n\n  // 33 bytes: the public key or private key data\n  if (!this.isNeutered()) {\n    // 0x00 + k for private keys\n    buffer.writeUInt8(0, 45)\n    this.privateKey.copy(buffer, 46)\n\n  // 33 bytes: the public key\n  } else {\n    // X9.62 encoding for public keys\n    this.publicKey.copy(buffer, 45)\n  }\n\n  return bs58check.encode(buffer)\n}\n\nBIP32.prototype.toWIF = function () {\n  if (!this.privateKey) throw new TypeError('Missing private key')\n  return wif.encode(this.network.wif, this.privateKey, true)\n}\n\nlet HIGHEST_BIT = 0x80000000\n\n// https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions\nBIP32.prototype.derive = function (index) {\n  typeforce(typeforce.UInt32, index)\n\n  let isHardened = index >= HIGHEST_BIT\n  let data = Buffer.allocUnsafe(37)\n\n  // Hardened child\n  if (isHardened) {\n    if (this.isNeutered()) throw new TypeError('Missing private key for hardened child key')\n\n    // data = 0x00 || ser256(kpar) || ser32(index)\n    data[0] = 0x00\n    this.privateKey.copy(data, 1)\n    data.writeUInt32BE(index, 33)\n\n  // Normal child\n  } else {\n    // data = serP(point(kpar)) || ser32(index)\n    //      = serP(Kpar) || ser32(index)\n    this.publicKey.copy(data, 0)\n    data.writeUInt32BE(index, 33)\n  }\n\n  let I = crypto.hmacSHA512(this.chainCode, data)\n  let IL = I.slice(0, 32)\n  let IR = I.slice(32)\n\n  // if parse256(IL) >= n, proceed with the next value for i\n  if (!ecc.isPrivate(IL)) return this.derive(index + 1)\n\n  // Private parent key -> private child key\n  let hd\n  if (!this.isNeutered()) {\n    // ki = parse256(IL) + kpar (mod n)\n    let ki = ecc.privateAdd(this.privateKey, IL)\n\n    // In case ki == 0, proceed with the next value for i\n    if (ki == null) return this.derive(index + 1)\n\n    hd = fromPrivateKey(ki, IR, this.network)\n\n  // Public parent key -> public child key\n  } else {\n    // Ki = point(parse256(IL)) + Kpar\n    //    = G*IL + Kpar\n    let Ki = ecc.pointAddScalar(this.publicKey, IL, true)\n\n    // In case Ki is the point at infinity, proceed with the next value for i\n    if (Ki === null) return this.derive(index + 1)\n\n    hd = fromPublicKey(Ki, IR, this.network)\n  }\n\n  hd.depth = this.depth + 1\n  hd.index = index\n  hd.parentFingerprint = this.fingerprint.readUInt32BE(0)\n  return hd\n}\n\nlet UINT31_MAX = Math.pow(2, 31) - 1\nfunction UInt31 (value) {\n  return typeforce.UInt32(value) && value <= UINT31_MAX\n}\n\nBIP32.prototype.deriveHardened = function (index) {\n  typeforce(UInt31, index)\n\n  // Only derives hardened private keys by default\n  return this.derive(index + HIGHEST_BIT)\n}\n\nfunction BIP32Path (value) {\n  return typeforce.String(value) && value.match(/^(m\\/)?(\\d+'?\\/)*\\d+'?$/)\n}\n\nBIP32.prototype.derivePath = function (path) {\n  typeforce(BIP32Path, path)\n\n  let splitPath = path.split('/')\n  if (splitPath[0] === 'm') {\n    if (this.parentFingerprint) throw new TypeError('Expected master, got child')\n\n    splitPath = splitPath.slice(1)\n  }\n\n  return splitPath.reduce(function (prevHd, indexStr) {\n    let index\n    if (indexStr.slice(-1) === \"'\") {\n      index = parseInt(indexStr.slice(0, -1), 10)\n      return prevHd.deriveHardened(index)\n    } else {\n      index = parseInt(indexStr, 10)\n      return prevHd.derive(index)\n    }\n  }, this)\n}\n\nBIP32.prototype.sign = function (hash) {\n  return ecc.sign(hash, this.privateKey)\n}\n\nBIP32.prototype.verify = function (hash, signature) {\n  return ecc.verify(hash, this.publicKey, signature)\n}\n\nfunction fromBase58 (string, network) {\n  let buffer = bs58check.decode(string)\n  if (buffer.length !== 78) throw new TypeError('Invalid buffer length')\n  network = network || BITCOIN\n\n  // 4 bytes: version bytes\n  let version = buffer.readUInt32BE(0)\n  if (version !== network.bip32.private &&\n    version !== network.bip32.public) throw new TypeError('Invalid network version')\n\n  // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...\n  let depth = buffer[4]\n\n  // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n  let parentFingerprint = buffer.readUInt32BE(5)\n  if (depth === 0) {\n    if (parentFingerprint !== 0x00000000) throw new TypeError('Invalid parent fingerprint')\n  }\n\n  // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in MSB order. (0x00000000 if master key)\n  let index = buffer.readUInt32BE(9)\n  if (depth === 0 && index !== 0) throw new TypeError('Invalid index')\n\n  // 32 bytes: the chain code\n  let chainCode = buffer.slice(13, 45)\n  let hd\n\n  // 33 bytes: private key data (0x00 + k)\n  if (version === network.bip32.private) {\n    if (buffer.readUInt8(45) !== 0x00) throw new TypeError('Invalid private key')\n    let k = buffer.slice(46, 78)\n\n    hd = fromPrivateKey(k, chainCode, network)\n\n  // 33 bytes: public key data (0x02 + X or 0x03 + X)\n  } else {\n    let X = buffer.slice(45, 78)\n\n    hd = fromPublicKey(X, chainCode, network)\n  }\n\n  hd.depth = depth\n  hd.index = index\n  hd.parentFingerprint = parentFingerprint\n  return hd\n}\n\nfunction fromPrivateKey (privateKey, chainCode, network) {\n  typeforce({\n    privateKey: UINT256_TYPE,\n    chainCode: UINT256_TYPE\n  }, { privateKey, chainCode })\n  network = network || BITCOIN\n\n  if (!ecc.isPrivate(privateKey)) throw new TypeError('Private key not in range [1, n)')\n  return new BIP32(privateKey, null, chainCode, network)\n}\n\nfunction fromPublicKey (publicKey, chainCode, network) {\n  typeforce({\n    publicKey: typeforce.BufferN(33),\n    chainCode: UINT256_TYPE\n  }, { publicKey, chainCode })\n  network = network || BITCOIN\n\n  // verify the X coordinate is a point on the curve\n  if (!ecc.isPoint(publicKey)) throw new TypeError('Point is not on the curve')\n  return new BIP32(null, publicKey, chainCode, network)\n}\n\nfunction fromSeed (seed, network) {\n  typeforce(typeforce.Buffer, seed)\n  if (seed.length < 16) throw new TypeError('Seed should be at least 128 bits')\n  if (seed.length > 64) throw new TypeError('Seed should be at most 512 bits')\n  network = network || BITCOIN\n\n  let I = crypto.hmacSHA512('Bitcoin seed', seed)\n  let IL = I.slice(0, 32)\n  let IR = I.slice(32)\n\n  return fromPrivateKey(IL, IR, network)\n}\n\nmodule.exports = {\n  fromBase58,\n  fromPrivateKey,\n  fromPublicKey,\n  fromSeed\n}\n\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","BIP32","d","Q","chainCode","network","typeforce","NETWORK_TYPE","__d","__Q","index","depth","parentFingerprint","UInt31","value","UInt32","UINT31_MAX","BIP32Path","String","match","fromPrivateKey","privateKey","UINT256_TYPE","BITCOIN","ecc","isPrivate","TypeError","fromPublicKey","publicKey","BufferN","isPoint","Buffer","bs58check","crypto","wif","compile","UInt8","bip32","public","private","Object","defineProperty","prototype","get","hash160","identifier","slice","enumerable","pointFromScalar","compressed","isNeutered","BIP32.prototype.isNeutered","neutered","BIP32.prototype.neutered","toBase58","BIP32.prototype.toBase58","version","buffer","allocUnsafe","writeUInt32BE","writeUInt8","copy","encode","toWIF","BIP32.prototype.toWIF","derive","BIP32.prototype.derive","isHardened","HIGHEST_BIT","data","I","hmacSHA512","IL","IR","Ki","pointAddScalar","hd","ki","privateAdd","fingerprint","readUInt32BE","Math","pow","deriveHardened","BIP32.prototype.deriveHardened","derivePath","BIP32.prototype.derivePath","path","splitPath","split","reduce","prevHd","indexStr","parseInt","sign","BIP32.prototype.sign","hash","verify","BIP32.prototype.verify","signature","fromBase58","string","decode","length","readUInt8","k","X","fromSeed","seed"]
}
