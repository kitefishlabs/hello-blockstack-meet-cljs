{
"version":3,
"file":"module$node_modules$blockstack$lib$profiles$profileTokens.js",
"lineCount":7,
"mappings":"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",
"sources":["node_modules/blockstack/lib/profiles/profileTokens.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$blockstack$lib$profiles$profileTokens\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.signProfileToken = signProfileToken;\nexports.wrapProfileToken = wrapProfileToken;\nexports.verifyProfileToken = verifyProfileToken;\nexports.extractProfile = extractProfile;\n\nvar _bitcoinjsLib = require('bitcoinjs-lib');\n\nvar _jsontokens = require('jsontokens');\n\nvar _utils = require('../utils');\n\n/**\n  * Signs a profile token\n  * @param {Object} profile - the JSON of the profile to be signed\n  * @param {String} privateKey - the signing private key\n  * @param {Object} subject - the entity that the information is about\n  * @param {Object} issuer - the entity that is issuing the token\n  * @param {String} signingAlgorithm - the signing algorithm to use\n  * @param {Date} issuedAt - the time of issuance of the token\n  * @param {Date} expiresAt - the time of expiration of the token\n  * @returns {Object} - the signed profile token\n  */\nfunction signProfileToken(profile, privateKey) {\n  var subject = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var issuer = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var signingAlgorithm = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'ES256K';\n  var issuedAt = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new Date();\n  var expiresAt = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : (0, _utils.nextYear)();\n\n  if (signingAlgorithm !== 'ES256K') {\n    throw new Error('Signing algorithm not supported');\n  }\n\n  var publicKey = _jsontokens.SECP256K1Client.derivePublicKey(privateKey);\n\n  if (subject === null) {\n    subject = { publicKey: publicKey };\n  }\n\n  if (issuer === null) {\n    issuer = { publicKey: publicKey };\n  }\n\n  var tokenSigner = new _jsontokens.TokenSigner(signingAlgorithm, privateKey);\n\n  var payload = {\n    jti: (0, _utils.makeUUID4)(),\n    iat: issuedAt.toISOString(),\n    exp: expiresAt.toISOString(),\n    subject: subject,\n    issuer: issuer,\n    claim: profile\n  };\n\n  return tokenSigner.sign(payload);\n}\n\n/**\n  * Wraps a token for a profile token file\n  * @param {String} token - the token to be wrapped\n  * @returns {Object} - including `token` and `decodedToken`\n  */\nfunction wrapProfileToken(token) {\n  return {\n    token: token,\n    decodedToken: (0, _jsontokens.decodeToken)(token)\n  };\n}\n\n/**\n  * Verifies a profile token\n  * @param {String} token - the token to be verified\n  * @param {String} publicKeyOrAddress - the public key or address of the\n  *   keypair that is thought to have signed the token\n  * @returns {Object} - the verified, decoded profile token\n  * @throws {Error} - throws an error if token verification fails\n  */\nfunction verifyProfileToken(token, publicKeyOrAddress) {\n  var decodedToken = (0, _jsontokens.decodeToken)(token);\n  var payload = decodedToken.payload;\n\n  // Inspect and verify the subject\n  if (payload.hasOwnProperty('subject')) {\n    if (!payload.subject.hasOwnProperty('publicKey')) {\n      throw new Error('Token doesn\\'t have a subject public key');\n    }\n  } else {\n    throw new Error('Token doesn\\'t have a subject');\n  }\n\n  // Inspect and verify the issuer\n  if (payload.hasOwnProperty('issuer')) {\n    if (!payload.issuer.hasOwnProperty('publicKey')) {\n      throw new Error('Token doesn\\'t have an issuer public key');\n    }\n  } else {\n    throw new Error('Token doesn\\'t have an issuer');\n  }\n\n  // Inspect and verify the claim\n  if (!payload.hasOwnProperty('claim')) {\n    throw new Error('Token doesn\\'t have a claim');\n  }\n\n  var issuerPublicKey = payload.issuer.publicKey;\n  var publicKeyBuffer = new Buffer(issuerPublicKey, 'hex');\n\n  var compressedKeyPair = _bitcoinjsLib.ECPair.fromPublicKey(publicKeyBuffer, { compressed: true });\n  var compressedAddress = (0, _utils.ecPairToAddress)(compressedKeyPair);\n  var uncompressedKeyPair = _bitcoinjsLib.ECPair.fromPublicKey(publicKeyBuffer, { compressed: false });\n  var uncompressedAddress = (0, _utils.ecPairToAddress)(uncompressedKeyPair);\n\n  if (publicKeyOrAddress === issuerPublicKey) {\n    // pass\n  } else if (publicKeyOrAddress === compressedAddress) {\n    // pass\n  } else if (publicKeyOrAddress === uncompressedAddress) {\n    // pass\n  } else {\n    throw new Error('Token issuer public key does not match the verifying value');\n  }\n\n  var tokenVerifier = new _jsontokens.TokenVerifier(decodedToken.header.alg, issuerPublicKey);\n  if (!tokenVerifier) {\n    throw new Error('Invalid token verifier');\n  }\n\n  var tokenVerified = tokenVerifier.verify(token);\n  if (!tokenVerified) {\n    throw new Error('Token verification failed');\n  }\n\n  return decodedToken;\n}\n\n/**\n  * Extracts a profile from an encoded token and optionally verifies it,\n  * if `publicKeyOrAddress` is provided.\n  * @param {String} token - the token to be extracted\n  * @param {String} publicKeyOrAddress - the public key or address of the\n  *   keypair that is thought to have signed the token\n  * @returns {Object} - the profile extracted from the encoded token\n  * @throws {Error} - if the token isn't signed by the provided `publicKeyOrAddress`\n  */\nfunction extractProfile(token) {\n  var publicKeyOrAddress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  var decodedToken = void 0;\n  if (publicKeyOrAddress) {\n    decodedToken = verifyProfileToken(token, publicKeyOrAddress);\n  } else {\n    decodedToken = (0, _jsontokens.decodeToken)(token);\n  }\n\n  var profile = {};\n  if (decodedToken.hasOwnProperty('payload')) {\n    var payload = decodedToken.payload;\n    if (payload.hasOwnProperty('claim')) {\n      profile = decodedToken.payload.claim;\n    }\n  }\n\n  return profile;\n}\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","verifyProfileToken","token","publicKeyOrAddress","decodedToken","_jsontokens","decodeToken","payload","hasOwnProperty","subject","Error","issuer","issuerPublicKey","publicKey","publicKeyBuffer","Buffer","compressedKeyPair","_bitcoinjsLib","ECPair","fromPublicKey","compressed","compressedAddress","_utils","ecPairToAddress","uncompressedKeyPair","uncompressedAddress","tokenVerifier","TokenVerifier","header","alg","verify","tokenVerified","Object","defineProperty","value","signProfileToken","profile","privateKey","arguments","length","undefined","signingAlgorithm","issuedAt","Date","expiresAt","nextYear","SECP256K1Client","derivePublicKey","tokenSigner","TokenSigner","jti","makeUUID4","iat","toISOString","exp","claim","sign","wrapProfileToken","extractProfile"]
}
