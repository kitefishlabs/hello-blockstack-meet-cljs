shadow$provide.module$node_modules$elliptic$lib$elliptic$ec$index=function(global,process,require,module,exports,shadow$shims){function EC(options){if(!(this instanceof EC))return new EC(options);"string"===typeof options&&(assert(elliptic.curves.hasOwnProperty(options),"Unknown curve "+options),options=elliptic.curves[options]);options instanceof elliptic.curves.PresetCurve&&(options={curve:options});this.curve=options.curve.curve;this.n=this.curve.n;this.nh=this.n.ushrn(1);this.g=this.curve.g;this.g=
options.curve.g;this.g.precompute(options.curve.n.bitLength()+1);this.hash=options.hash||options.curve.hash}var BN=require("module$node_modules$bn_DOT_js$lib$bn"),HmacDRBG=require("module$node_modules$hmac_drbg$lib$hmac_drbg"),elliptic=require("module$node_modules$elliptic$lib$elliptic"),assert=elliptic.utils.assert,KeyPair=require("module$node_modules$elliptic$lib$elliptic$ec$key"),Signature=require("module$node_modules$elliptic$lib$elliptic$ec$signature");module.exports=EC;EC.prototype.keyPair=
function(options){return new KeyPair(this,options)};EC.prototype.keyFromPrivate=function(priv,enc){return KeyPair.fromPrivate(this,priv,enc)};EC.prototype.keyFromPublic=function(pub,enc){return KeyPair.fromPublic(this,pub,enc)};EC.prototype.genKeyPair=function(options){options||(options={});options=new HmacDRBG({hash:this.hash,pers:options.pers,persEnc:options.persEnc||"utf8",entropy:options.entropy||elliptic.rand(this.hash.hmacStrength),entropyEnc:options.entropy&&options.entropyEnc||"utf8",nonce:this.n.toArray()});
var bytes=this.n.byteLength(),ns2=this.n.sub(new BN(2));do{var priv=new BN(options.generate(bytes));if(!(0<priv.cmp(ns2)))return priv.iaddn(1),this.keyFromPrivate(priv)}while(1)};EC.prototype._truncateToN=function(msg,truncOnly){var delta=8*msg.byteLength()-this.n.bitLength();0<delta&&(msg=msg.ushrn(delta));return!truncOnly&&0<=msg.cmp(this.n)?msg.sub(this.n):msg};EC.prototype.sign=function(msg,key,enc,options){"object"===typeof enc&&(options=enc,enc=null);options||(options={});key=this.keyFromPrivate(key,
enc);msg=this._truncateToN(new BN(msg,16));var bytes=this.n.byteLength();enc=key.getPrivate().toArray("be",bytes);bytes=msg.toArray("be",bytes);bytes=new HmacDRBG({hash:this.hash,entropy:enc,nonce:bytes,pers:options.pers,persEnc:options.persEnc||"utf8"});for(var ns1=this.n.sub(new BN(1)),iter=0;;iter++){var k=options.k?options.k(iter):new BN(bytes.generate(this.n.byteLength()));k=this._truncateToN(k,!0);if(!(0>=k.cmpn(1)||0<=k.cmp(ns1))){var kp=this.g.mul(k);if(!kp.isInfinity()){var kpX=kp.getX();
enc=kpX.umod(this.n);if(0!==enc.cmpn(0)&&(k=k.invm(this.n).mul(enc.mul(key.getPrivate()).iadd(msg)),k=k.umod(this.n),0!==k.cmpn(0)))return msg=(kp.getY().isOdd()?1:0)|(0!==kpX.cmp(enc)?2:0),options.canonical&&0<k.cmp(this.nh)&&(k=this.n.sub(k),msg^=1),new Signature({r:enc,s:k,recoveryParam:msg})}}}};EC.prototype.verify=function(msg,signature,key,enc){msg=this._truncateToN(new BN(msg,16));key=this.keyFromPublic(key,enc);signature=new Signature(signature,"hex");enc=signature.r;signature=signature.s;
if(0>enc.cmpn(1)||0<=enc.cmp(this.n)||0>signature.cmpn(1)||0<=signature.cmp(this.n))return!1;signature=signature.invm(this.n);msg=signature.mul(msg).umod(this.n);signature=signature.mul(enc).umod(this.n);if(!this.curve._maxwellTrick)return key=this.g.mulAdd(msg,key.getPublic(),signature),key.isInfinity()?!1:0===key.getX().umod(this.n).cmp(enc);key=this.g.jmulAdd(msg,key.getPublic(),signature);return key.isInfinity()?!1:key.eqXToP(enc)};EC.prototype.recoverPubKey=function(msg,signature,j,enc){assert((3&
j)===j,"The recovery param is more than two bits");signature=new Signature(signature,enc);enc=this.n;var e=new BN(msg);msg=signature.r;var s=signature.s,isYOdd=j&1;j>>=1;if(0<=msg.cmp(this.curve.p.umod(this.curve.n))&&j)throw Error("Unable to find sencond key candinate");msg=j?this.curve.pointFromX(msg.add(this.curve.n),isYOdd):this.curve.pointFromX(msg,isYOdd);signature=signature.r.invm(enc);j=enc.sub(e).mul(signature).umod(enc);enc=s.mul(signature).umod(enc);return this.g.mulAdd(j,msg,enc)};EC.prototype.getKeyRecoveryParam=
function(e,signature,Q,enc){signature=new Signature(signature,enc);if(null!==signature.recoveryParam)return signature.recoveryParam;for(enc=0;4>enc;enc++){try{var Qprime=this.recoverPubKey(e,signature,enc)}catch(e$8){continue}if(Qprime.eq(Q))return enc}throw Error("Unable to find valid recovery factor");}}
//# sourceMappingURL=module$node_modules$elliptic$lib$elliptic$ec$index.js.map
