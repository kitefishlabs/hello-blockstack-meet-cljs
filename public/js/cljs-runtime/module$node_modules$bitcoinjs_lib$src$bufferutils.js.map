{
"version":3,
"file":"module$node_modules$bitcoinjs_lib$src$bufferutils.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,kDAAA,CAAsE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,OAAhB,CAAwBC,MAAxB,CAA+BC,OAA/B,CAAuCC,YAAvC,CAAqD,CAEnIC,QAASA,UAAU,CAACC,KAAD,CAAQC,GAAR,CAAa,CAC9B,GAAqB,QAArB,GAAI,MAAOD,MAAX,CAA+B,KAAUE,MAAJ,CAAU,uCAAV,CAAN,CAC/B,GAAY,CAAZ,CAAIF,KAAJ,CAAe,KAAUE,MAAJ,CAAU,0DAAV,CAAN,CACf,GAAIF,KAAJ,CAAYC,GAAZ,CAAiB,KAAUC,MAAJ,CAAU,gCAAV,CAAN,CACjB,GAAIC,IAAAC,MAAA,CAAWJ,KAAX,CAAJ,GAA0BA,KAA1B,CAAiC,KAAUE,MAAJ,CAAU,kCAAV,CAAN,CAJH,CAwBhCN,MAAAC,QAAA,CAAiB,CACfQ,aAlBFA,QAAsB,CAACC,MAAD;AAASC,MAAT,CAAiB,CACrC,IAAMC,EAAIF,MAAAG,aAAA,CAAoBF,MAApB,CACNG,OAAAA,CAAIJ,MAAAG,aAAA,CAAoBF,MAApB,CAA6B,CAA7B,CACRG,OAAA,EAAK,UAELX,UAAA,CAAUW,MAAV,CAAcF,CAAd,CAAiB,gBAAjB,CACA,OAAOE,OAAP,CAAWF,CAN0B,CAiBtB,CAEfG,cAVFA,QAAuB,CAACL,MAAD,CAASN,KAAT,CAAgBO,MAAhB,CAAwB,CAC7CR,SAAA,CAAUC,KAAV,CAAiB,gBAAjB,CAEAM,OAAAM,aAAA,CAAoBZ,KAApB,CAA6B,EAA7B,CAAgCO,MAAhC,CACAD,OAAAO,cAAA,CAAqBV,IAAAC,MAAA,CAAWJ,KAAX,CAAmB,UAAnB,CAArB,CAAsDO,MAAtD,CAA+D,CAA/D,CACA,OAAOA,OAAP,CAAgB,CAL6B,CAQ9B,CA1BkH;",
"sources":["node_modules/bitcoinjs-lib/src/bufferutils.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$bitcoinjs_lib$src$bufferutils\"] = function(global,process,require,module,exports,shadow$shims) {\n// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint (value, max) {\n  if (typeof value !== 'number') throw new Error('cannot write a non-number as a number')\n  if (value < 0) throw new Error('specified a negative value for writing an unsigned value')\n  if (value > max) throw new Error('RangeError: value out of range')\n  if (Math.floor(value) !== value) throw new Error('value has a fractional component')\n}\n\nfunction readUInt64LE (buffer, offset) {\n  const a = buffer.readUInt32LE(offset)\n  let b = buffer.readUInt32LE(offset + 4)\n  b *= 0x100000000\n\n  verifuint(b + a, 0x001fffffffffffff)\n  return b + a\n}\n\nfunction writeUInt64LE (buffer, value, offset) {\n  verifuint(value, 0x001fffffffffffff)\n\n  buffer.writeInt32LE(value & -1, offset)\n  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4)\n  return offset + 8\n}\n\nmodule.exports = {\n  readUInt64LE: readUInt64LE,\n  writeUInt64LE: writeUInt64LE\n}\n\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","verifuint","value","max","Error","Math","floor","readUInt64LE","buffer","offset","a","readUInt32LE","b","writeUInt64LE","writeInt32LE","writeUInt32LE"]
}
