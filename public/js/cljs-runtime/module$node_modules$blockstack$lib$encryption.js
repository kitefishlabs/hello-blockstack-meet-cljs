shadow$provide.module$node_modules$blockstack$lib$encryption=function(global,process,require,module,exports,shadow$shims){function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _inherits(subClass,superClass){if("function"!==typeof superClass&&null!==superClass)throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,
writable:!0,configurable:!0}});superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)}function hmacSha256(key,content){return _crypto2.default.createHmac("sha256",key).update(content).digest()}function sharedSecretToKeys(sharedSecret){sharedSecret=_crypto2.default.createHash("sha512").update(sharedSecret).digest();return{encryptionKey:sharedSecret.slice(0,32),hmacKey:sharedSecret.slice(32)}}function getHexFromBN(bnInput){bnInput=bnInput.toString("hex");
if(64===bnInput.length)return bnInput;if(64>bnInput.length)return""+"0".repeat(64-bnInput.length)+bnInput;throw Error("Generated a \x3e 32-byte BN for encryption. Failing.");}function decryptMnemonicBuffer(dataBuffer,password){return Promise.resolve().then(function(){var salt=dataBuffer.slice(0,16),hmacSig=dataBuffer.slice(16,48),cipherText=dataBuffer.slice(48),hmacPayload=shadow$shims.Buffer.concat([salt,cipherText]),keysAndIV=_crypto2.default.pbkdf2Sync(password,salt,1E5,48,"sha512"),encKey=keysAndIV.slice(0,
16);salt=keysAndIV.slice(16,32);keysAndIV=keysAndIV.slice(32,48);encKey=_crypto2.default.createDecipheriv("aes-128-cbc",encKey,keysAndIV);cipherText=encKey.update(cipherText).toString("hex");cipherText+=encKey.final().toString("hex");salt=_crypto2.default.createHmac("sha256",salt);salt.write(hmacPayload);hmacPayload=salt.digest();hmacSig=_crypto2.default.createHash("sha256").update(hmacSig).digest().toString("hex");hmacPayload=_crypto2.default.createHash("sha256").update(hmacPayload).digest().toString("hex");
if(hmacSig!==hmacPayload)throw new PasswordError("Wrong password (HMAC mismatch)");hmacSig=_bip2.default.entropyToMnemonic(cipherText);if(!_bip2.default.validateMnemonic(hmacSig))throw new PasswordError("Wrong password (invalid plaintext)");return hmacSig})}function decryptLegacy(dataBuffer,password){return new Promise(function(resolve,reject){_triplesec2.default.decrypt({key:shadow$shims.Buffer.from(password),data:dataBuffer},function(err,plaintextBuffer){err?reject(err):resolve(plaintextBuffer)})})}
Object.defineProperty(exports,"__esModule",{value:!0});exports.getHexFromBN=getHexFromBN;exports.encryptECIES=function(publicKey,content){var isString="string"===typeof content;content=shadow$shims.Buffer.from(content);var ecPK=ecurve.keyFromPublic(publicKey,"hex").getPublic(),ephemeralSK=ecurve.genKeyPair();publicKey=ephemeralSK.getPublic();ecPK=ephemeralSK.derive(ecPK);ecPK=getHexFromBN(ecPK);ephemeralSK=sharedSecretToKeys(new shadow$shims.Buffer(ecPK,"hex"));ecPK=_crypto2.default.randomBytes(16);
var cipher=_crypto2.default.createCipheriv("aes-256-cbc",ephemeralSK.encryptionKey,ecPK);content=shadow$shims.Buffer.concat([cipher.update(content),cipher.final()]);cipher=shadow$shims.Buffer.concat([ecPK,new shadow$shims.Buffer(publicKey.encodeCompressed()),content]);ephemeralSK=hmacSha256(ephemeralSK.hmacKey,cipher);return{iv:ecPK.toString("hex"),ephemeralPK:publicKey.encodeCompressed("hex"),cipherText:content.toString("hex"),mac:ephemeralSK.toString("hex"),wasString:isString}};exports.decryptECIES=
function(privateKey,cipherObject){privateKey=ecurve.keyFromPrivate(privateKey,"hex");var ephemeralPK=ecurve.keyFromPublic(cipherObject.ephemeralPK,"hex").getPublic();privateKey=privateKey.derive(ephemeralPK);privateKey=new shadow$shims.Buffer(getHexFromBN(privateKey),"hex");var sharedKeys=sharedSecretToKeys(privateKey),ivBuffer=new shadow$shims.Buffer(cipherObject.iv,"hex");privateKey=new shadow$shims.Buffer(cipherObject.cipherText,"hex");ephemeralPK=shadow$shims.Buffer.concat([ivBuffer,new shadow$shims.Buffer(ephemeralPK.encodeCompressed()),
privateKey]);ephemeralPK=hmacSha256(sharedKeys.hmacKey,ephemeralPK);var expectedMac=new shadow$shims.Buffer(cipherObject.mac,"hex");if(expectedMac.length!==ephemeralPK.length)ephemeralPK=!1;else{for(var res=0,i=0;i<expectedMac.length;i++)res|=expectedMac[i]^ephemeralPK[i];ephemeralPK=0===res}if(!ephemeralPK)throw Error("Decryption failed: failure in MAC check");sharedKeys=_crypto2.default.createDecipheriv("aes-256-cbc",sharedKeys.encryptionKey,ivBuffer);privateKey=shadow$shims.Buffer.concat([sharedKeys.update(privateKey),
sharedKeys.final()]);return cipherObject.wasString?privateKey.toString():privateKey};exports.signECDSA=function(privateKey,content){var contentBuffer=shadow$shims.Buffer.from(content);content=ecurve.keyFromPrivate(privateKey,"hex");privateKey=(0,_keys.getPublicKeyFromPrivate)(privateKey);contentBuffer=_crypto2.default.createHash("sha256").update(contentBuffer).digest();return{signature:content.sign(contentBuffer).toDER("hex"),publicKey:privateKey}};exports.verifyECDSA=function(content,publicKey,signature){content=
shadow$shims.Buffer.from(content);publicKey=ecurve.keyFromPublic(publicKey,"hex");content=_crypto2.default.createHash("sha256").update(content).digest();return publicKey.verify(content,signature)};exports.encryptMnemonic=function(phrase,password){return Promise.resolve().then(function(){if(!_bip2.default.validateMnemonic(phrase))throw Error("Not a valid bip39 nmemonic");var plaintextNormalized=shadow$shims.Buffer.from(_bip2.default.mnemonicToEntropy(phrase).toString("hex"),"hex"),salt=_crypto2.default.randomBytes(16),
keysAndIV=_crypto2.default.pbkdf2Sync(password,salt,1E5,48,"sha512"),encKey=keysAndIV.slice(0,16),macKey=keysAndIV.slice(16,32);keysAndIV=keysAndIV.slice(32,48);encKey=_crypto2.default.createCipheriv("aes-128-cbc",encKey,keysAndIV);plaintextNormalized=encKey.update(plaintextNormalized).toString("hex");plaintextNormalized+=encKey.final().toString("hex");encKey=shadow$shims.Buffer.concat([salt,shadow$shims.Buffer.from(plaintextNormalized,"hex")]);macKey=_crypto2.default.createHmac("sha256",macKey);
macKey.write(encKey);macKey=macKey.digest();return shadow$shims.Buffer.concat([salt,macKey,shadow$shims.Buffer.from(plaintextNormalized,"hex")])})};exports.decryptMnemonic=function(data,password){var dataBuffer=shadow$shims.Buffer.isBuffer(data)?data:shadow$shims.Buffer.from(data,"hex");return decryptMnemonicBuffer(dataBuffer,password).catch(function(err){if(err instanceof PasswordError)throw err;return decryptLegacy(dataBuffer,password)})};global=require("module$node_modules$elliptic$lib$elliptic");
process=require("module$node_modules$crypto_browserify$index");var _crypto2=_interopRequireDefault(process);process=require("module$node_modules$bip39$index");var _bip2=_interopRequireDefault(process);process=require("module$node_modules$triplesec$lib$main");var _triplesec2=_interopRequireDefault(process),_keys=require("module$node_modules$blockstack$lib$keys"),ecurve=new global.ec("secp256k1"),PasswordError=function(_Error){function PasswordError(){if(!(this instanceof PasswordError))throw new TypeError("Cannot call a class as a function");
var call=(PasswordError.__proto__||Object.getPrototypeOf(PasswordError)).apply(this,arguments);if(!this)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!call||"object"!==typeof call&&"function"!==typeof call?this:call}_inherits(PasswordError,_Error);return PasswordError}(Error)}
//# sourceMappingURL=module$node_modules$blockstack$lib$encryption.js.map
