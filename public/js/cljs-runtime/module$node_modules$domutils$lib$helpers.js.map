{
"version":3,
"file":"module$node_modules$domutils$lib$helpers.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,yCAAA,CAA6D,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,OAAhB,CAAwBC,MAAxB,CAA+BC,OAA/B,CAAuCC,YAAvC,CAAqD,CAG1HD,OAAAE,cAAA,CAAwBC,QAAQ,CAACC,KAAD,CAAQ,CAKvC,IALuC,IACnCC,IAAMD,KAAAE,OAD6B,CACfC,IADe,CACTC,QADS,CACCC,OAIxC,CAAgB,EAAhB,CAAO,EAAEJ,GAAT,CAAA,CAAmB,CAClBE,IAAA,CAAOC,QAAP,CAAkBJ,KAAA,CAAMC,GAAN,CAGlBD,MAAA,CAAMC,GAAN,CAAA,CAAa,IAGb,KAFAI,OAEA,CAFU,CAAA,CAEV,CAAOD,QAAP,CAAA,CAAiB,CAChB,GAA+B,EAA/B,CAAIJ,KAAAM,QAAA,CAAcF,QAAd,CAAJ,CAAkC,CACjCC,OAAA,CAAU,CAAA,CACVL,MAAAO,OAAA,CAAaN,GAAb,CAAkB,CAAlB,CACA,MAHiC,CAKlCG,QAAA,CAAWA,QAAAI,OANK,CAUbH,OAAJ,GACCL,KAAA,CAAMC,GAAN,CADD,CACcE,IADd,CAjBkB,CAsBnB,MAAOH,MA3BgC,CA6DxC,KAAIS,WAAab,OAAAc,wBAAbD,CAA+CE,QAAQ,CAACC,KAAD,CAAQC,KAAR,CAAe,CACzE,IAAIC,SAAW,EAAf,CACIC;AAAW,EADf,CAEIC,OAFJ,CAEyDf,GAEzD,IAAIW,KAAJ,GAAcC,KAAd,CACC,MAAO,EAIR,KADAG,OACA,CADUJ,KACV,CAAOI,OAAP,CAAA,CACCF,QAAAG,QAAA,CAAiBD,OAAjB,CACA,CAAAA,OAAA,CAAUA,OAAAR,OAGX,KADAQ,OACA,CADUH,KACV,CAAOG,OAAP,CAAA,CACCD,QAAAE,QAAA,CAAiBD,OAAjB,CACA,CAAAA,OAAA,CAAUA,OAAAR,OAIX,KADAP,GACA,CADM,CACN,CAAOa,QAAA,CAASb,GAAT,CAAP,GAAyBc,QAAA,CAASd,GAAT,CAAzB,CAAA,CACCA,GAAA,EAGD,IAAY,CAAZ,GAAIA,GAAJ,CACC,MAvDaiB,EA0DdC,QAAA,CAAeL,QAAA,CAASb,GAAT,CAAe,CAAf,CACf,KAAAmB,SAAWD,OAAAE,SACXC,SAAA,CAAWR,QAAA,CAASb,GAAT,CACXsB,SAAA,CAAWR,QAAA,CAASd,GAAT,CAEX,OAAImB,SAAAd,QAAA,CAAiBgB,QAAjB,CAAJ,CAAiCF,QAAAd,QAAA,CAAiBiB,QAAjB,CAAjC,CACKJ,OAAJ,GAAqBN,KAArB,CACQ,EADR,CA9DUW,CA6DX,CAMKL,OAAJ,GAAqBP,KAArB,CACQ,EADR,CApEUa,CA4B8D,CAsD1E7B,QAAA8B,WAAA,CAAqBC,QAAQ,CAAC3B,KAAD,CAAQ,CAAA,IAChCC;AAAMD,KAAAE,OAIV,KAFAF,KAEA,CAFQA,KAAA4B,MAAA,EAER,CAAgB,EAAhB,CAAO,EAAE3B,GAAT,CAAA,CAAmB,CAClB,IAAAE,KAAOH,KAAA,CAAMC,GAAN,CACP4B,KAAA,CAAW7B,KAAAM,QAAA,CAAcH,IAAd,CACK,GAAhB,CAAI0B,IAAJ,EAAqBA,IAArB,CAAgC5B,GAAhC,EACCD,KAAAO,OAAA,CAAaN,GAAb,CAAkB,CAAlB,CAJiB,CAOnBD,KAAA8B,KAAA,CAAW,QAAQ,CAACC,CAAD,CAAIC,CAAJ,CAAO,CACrBC,CAAAA,CAAWxB,UAAA,CAAWsB,CAAX,CAAcC,CAAd,CACf,OAAIC,EAAJ,CAhGUR,CAgGV,CACS,EADT,CAEWQ,CAAJ,CAjGGT,CAiGH,CACC,CADD,CAGA,CAPkB,CAA1B,CAUA,OAAOxB,MAtB6B,CAtHqF;",
"sources":["node_modules/domutils/lib/helpers.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$domutils$lib$helpers\"] = function(global,process,require,module,exports,shadow$shims) {\n// removeSubsets\n// Given an array of nodes, remove any member that is contained by another.\nexports.removeSubsets = function(nodes) {\n\tvar idx = nodes.length, node, ancestor, replace;\n\n\t// Check if each node (or one of its ancestors) is already contained in the\n\t// array.\n\twhile (--idx > -1) {\n\t\tnode = ancestor = nodes[idx];\n\n\t\t// Temporarily remove the node under consideration\n\t\tnodes[idx] = null;\n\t\treplace = true;\n\n\t\twhile (ancestor) {\n\t\t\tif (nodes.indexOf(ancestor) > -1) {\n\t\t\t\treplace = false;\n\t\t\t\tnodes.splice(idx, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tancestor = ancestor.parent;\n\t\t}\n\n\t\t// If the node has been found to be unique, re-insert it.\n\t\tif (replace) {\n\t\t\tnodes[idx] = node;\n\t\t}\n\t}\n\n\treturn nodes;\n};\n\n// Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition\nvar POSITION = {\n\tDISCONNECTED: 1,\n\tPRECEDING: 2,\n\tFOLLOWING: 4,\n\tCONTAINS: 8,\n\tCONTAINED_BY: 16\n};\n\n// Compare the position of one node against another node in any other document.\n// The return value is a bitmask with the following values:\n//\n// document order:\n// > There is an ordering, document order, defined on all the nodes in the\n// > document corresponding to the order in which the first character of the\n// > XML representation of each node occurs in the XML representation of the\n// > document after expansion of general entities. Thus, the document element\n// > node will be the first node. Element nodes occur before their children.\n// > Thus, document order orders element nodes in order of the occurrence of\n// > their start-tag in the XML (after expansion of entities). The attribute\n// > nodes of an element occur after the element and before its children. The\n// > relative order of attribute nodes is implementation-dependent./\n// Source:\n// http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order\n//\n// @argument {Node} nodaA The first node to use in the comparison\n// @argument {Node} nodeB The second node to use in the comparison\n//\n// @return {Number} A bitmask describing the input nodes' relative position.\n//         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for\n//         a description of these values.\nvar comparePos = exports.compareDocumentPosition = function(nodeA, nodeB) {\n\tvar aParents = [];\n\tvar bParents = [];\n\tvar current, sharedParent, siblings, aSibling, bSibling, idx;\n\n\tif (nodeA === nodeB) {\n\t\treturn 0;\n\t}\n\n\tcurrent = nodeA;\n\twhile (current) {\n\t\taParents.unshift(current);\n\t\tcurrent = current.parent;\n\t}\n\tcurrent = nodeB;\n\twhile (current) {\n\t\tbParents.unshift(current);\n\t\tcurrent = current.parent;\n\t}\n\n\tidx = 0;\n\twhile (aParents[idx] === bParents[idx]) {\n\t\tidx++;\n\t}\n\n\tif (idx === 0) {\n\t\treturn POSITION.DISCONNECTED;\n\t}\n\n\tsharedParent = aParents[idx - 1];\n\tsiblings = sharedParent.children;\n\taSibling = aParents[idx];\n\tbSibling = bParents[idx];\n\n\tif (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {\n\t\tif (sharedParent === nodeB) {\n\t\t\treturn POSITION.FOLLOWING | POSITION.CONTAINED_BY;\n\t\t}\n\t\treturn POSITION.FOLLOWING;\n\t} else {\n\t\tif (sharedParent === nodeA) {\n\t\t\treturn POSITION.PRECEDING | POSITION.CONTAINS;\n\t\t}\n\t\treturn POSITION.PRECEDING;\n\t}\n};\n\n// Sort an array of nodes based on their relative position in the document and\n// remove any duplicate nodes. If the array contains nodes that do not belong\n// to the same document, sort order is unspecified.\n//\n// @argument {Array} nodes Array of DOM nodes\n//\n// @returns {Array} collection of unique nodes, sorted in document order\nexports.uniqueSort = function(nodes) {\n\tvar idx = nodes.length, node, position;\n\n\tnodes = nodes.slice();\n\n\twhile (--idx > -1) {\n\t\tnode = nodes[idx];\n\t\tposition = nodes.indexOf(node);\n\t\tif (position > -1 && position < idx) {\n\t\t\tnodes.splice(idx, 1);\n\t\t}\n\t}\n\tnodes.sort(function(a, b) {\n\t\tvar relative = comparePos(a, b);\n\t\tif (relative & POSITION.PRECEDING) {\n\t\t\treturn -1;\n\t\t} else if (relative & POSITION.FOLLOWING) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t});\n\n\treturn nodes;\n};\n\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","removeSubsets","exports.removeSubsets","nodes","idx","length","node","ancestor","replace","indexOf","splice","parent","comparePos","compareDocumentPosition","exports.compareDocumentPosition","nodeA","nodeB","aParents","bParents","current","unshift","DISCONNECTED","sharedParent","siblings","children","aSibling","bSibling","FOLLOWING","PRECEDING","uniqueSort","exports.uniqueSort","slice","position","sort","a","b","relative"]
}
