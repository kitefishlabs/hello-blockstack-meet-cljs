shadow$provide.module$node_modules$elliptic$lib$elliptic$curve$mont=function(global,process,require,module,exports,shadow$shims){function MontCurve(conf){Base.call(this,"mont",conf);this.a=(new BN(conf.a,16)).toRed(this.red);this.b=(new BN(conf.b,16)).toRed(this.red);this.i4=(new BN(4)).toRed(this.red).redInvm();this.two=(new BN(2)).toRed(this.red);this.a24=this.i4.redMul(this.a.redAdd(this.two))}function Point(curve,x,z){Base.BasePoint.call(this,curve,"projective");null===x&&null===z?(this.x=this.curve.one,
this.z=this.curve.zero):(this.x=new BN(x,16),this.z=new BN(z,16),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)))}global=require("module$node_modules$elliptic$lib$elliptic$curve$index");var BN=require("module$node_modules$bn_DOT_js$lib$bn");process=require("module$node_modules$inherits$inherits_browser");var Base=global.base,utils=require("module$node_modules$elliptic$lib$elliptic").utils;process(MontCurve,Base);module.exports=MontCurve;MontCurve.prototype.validate=
function(point){point=point.normalize().x;var x2=point.redSqr();point=x2.redMul(point).redAdd(x2.redMul(this.a)).redAdd(point);return 0===point.redSqrt().redSqr().cmp(point)};process(Point,Base.BasePoint);MontCurve.prototype.decodePoint=function(bytes,enc){return this.point(utils.toArray(bytes,enc),1)};MontCurve.prototype.point=function(x,z){return new Point(this,x,z)};MontCurve.prototype.pointFromJSON=function(obj){return Point.fromJSON(this,obj)};Point.prototype.precompute=function(){};Point.prototype._encode=
function(){return this.getX().toArray("be",this.curve.p.byteLength())};Point.fromJSON=function(curve,obj){return new Point(curve,obj[0],obj[1]||curve.one)};Point.prototype.inspect=function(){return this.isInfinity()?"\x3cEC Point Infinity\x3e":"\x3cEC Point x: "+this.x.fromRed().toString(16,2)+" z: "+this.z.fromRed().toString(16,2)+"\x3e"};Point.prototype.isInfinity=function(){return 0===this.z.cmpn(0)};Point.prototype.dbl=function(){var aa=this.x.redAdd(this.z).redSqr(),bb=this.x.redSub(this.z).redSqr(),
c=aa.redSub(bb);aa=aa.redMul(bb);bb=c.redMul(bb.redAdd(this.curve.a24.redMul(c)));return this.curve.point(aa,bb)};Point.prototype.add=function(){throw Error("Not supported on Montgomery curve");};Point.prototype.diffAdd=function(p,diff){var a=this.x.redAdd(this.z),b=this.x.redSub(this.z),c=p.x.redAdd(p.z);p=p.x.redSub(p.z).redMul(a);c=c.redMul(b);b=diff.z.redMul(p.redAdd(c).redSqr());diff=diff.x.redMul(p.redISub(c).redSqr());return this.curve.point(b,diff)};Point.prototype.mul=function(k){var t=k.clone();
k=this;for(var b=this.curve.point(null,null),bits=[];0!==t.cmpn(0);t.iushrn(1))bits.push(t.andln(1));for(t=bits.length-1;0<=t;t--)0===bits[t]?(k=k.diffAdd(b,this),b=b.dbl()):(b=k.diffAdd(b,this),k=k.dbl());return b};Point.prototype.mulAdd=function(){throw Error("Not supported on Montgomery curve");};Point.prototype.jumlAdd=function(){throw Error("Not supported on Montgomery curve");};Point.prototype.eq=function(other){return 0===this.getX().cmp(other.getX())};Point.prototype.normalize=function(){this.x=
this.x.redMul(this.z.redInvm());this.z=this.curve.one;return this};Point.prototype.getX=function(){this.normalize();return this.x.fromRed()}}
//# sourceMappingURL=module$node_modules$elliptic$lib$elliptic$curve$mont.js.map
