shadow$provide.module$node_modules$elliptic$lib$elliptic$curve$base=function(global,process,require,module,exports,shadow$shims){function BaseCurve(type,conf){this.type=type;this.p=new BN(conf.p,16);this.red=conf.prime?BN.red(conf.prime):BN.mont(this.p);this.zero=(new BN(0)).toRed(this.red);this.one=(new BN(1)).toRed(this.red);this.two=(new BN(2)).toRed(this.red);this.n=conf.n&&new BN(conf.n,16);this.g=conf.g&&this.pointFromJSON(conf.g,conf.gRed);this._wnafT1=Array(4);this._wnafT2=Array(4);this._wnafT3=
Array(4);this._wnafT4=Array(4);type=this.n&&this.p.div(this.n);!type||0<type.cmpn(100)?this.redN=null:(this._maxwellTrick=!0,this.redN=this.n.toRed(this.red))}function BasePoint(curve,type){this.curve=curve;this.type=type;this.precomputed=null}var BN=require("module$node_modules$bn_DOT_js$lib$bn"),utils=require("module$node_modules$elliptic$lib$elliptic").utils,getNAF=utils.getNAF,getJSF=utils.getJSF,assert=utils.assert;module.exports=BaseCurve;BaseCurve.prototype.point=function(){throw Error("Not implemented");
};BaseCurve.prototype.validate=function(){throw Error("Not implemented");};BaseCurve.prototype._fixedNafMul=function(p,k){assert(p.precomputed);p=p._getDoubles();var naf=getNAF(k,1),I=(1<<p.step+1)-(0===p.step%2?2:1);I/=3;for(var repr=[],j=0;j<naf.length;j+=p.step){var nafW=0;for(k=j+p.step-1;k>=j;k--)nafW=(nafW<<1)+naf[k];repr.push(nafW)}k=this.jpoint(null,null,null);for(naf=this.jpoint(null,null,null);0<I;I--){for(j=0;j<repr.length;j++)nafW=repr[j],nafW===I?naf=naf.mixedAdd(p.points[j]):nafW===
-I&&(naf=naf.mixedAdd(p.points[j].neg()));k=k.add(naf)}return k.toP()};BaseCurve.prototype._wnafMul=function(p,k){var nafPoints=p._getNAFPoints(4),wnd=nafPoints.points;nafPoints=getNAF(k,nafPoints.wnd);for(var acc=this.jpoint(null,null,null),i=nafPoints.length-1;0<=i;i--){for(k=0;0<=i&&0===nafPoints[i];i--)k++;0<=i&&k++;acc=acc.dblp(k);if(0>i)break;k=nafPoints[i];assert(0!==k);acc="affine"===p.type?0<k?acc.mixedAdd(wnd[k-1>>1]):acc.mixedAdd(wnd[-k-1>>1].neg()):0<k?acc.add(wnd[k-1>>1]):acc.add(wnd[-k-
1>>1].neg())}return"affine"===p.type?acc.toP():acc};BaseCurve.prototype._wnafMulAdd=function(defW,points,coeffs,len,jacobianResult){for(var wndWidth=this._wnafT1,wnd=this._wnafT2,naf=this._wnafT3,max=0,i=0;i<len;i++){var p=points[i],nafPoints=p._getNAFPoints(defW);wndWidth[i]=nafPoints.wnd;wnd[i]=nafPoints.points}for(i=len-1;1<=i;i-=2){nafPoints=i-1;var b=i;if(1!==wndWidth[nafPoints]||1!==wndWidth[b])naf[nafPoints]=getNAF(coeffs[nafPoints],wndWidth[nafPoints]),naf[b]=getNAF(coeffs[b],wndWidth[b]),
max=Math.max(naf[nafPoints].length,max),max=Math.max(naf[b].length,max);else{var comb=[points[nafPoints],null,null,points[b]];0===points[nafPoints].y.cmp(points[b].y)?(comb[1]=points[nafPoints].add(points[b]),comb[2]=points[nafPoints].toJ().mixedAdd(points[b].neg())):0===points[nafPoints].y.cmp(points[b].y.redNeg())?(comb[1]=points[nafPoints].toJ().mixedAdd(points[b]),comb[2]=points[nafPoints].add(points[b].neg())):(comb[1]=points[nafPoints].toJ().mixedAdd(points[b]),comb[2]=points[nafPoints].toJ().mixedAdd(points[b].neg()));
var index=[-3,-1,-5,-7,0,7,5,1,3],jsf=getJSF(coeffs[nafPoints],coeffs[b]);max=Math.max(jsf[0].length,max);naf[nafPoints]=Array(max);naf[b]=Array(max);for(defW=0;defW<max;defW++)naf[nafPoints][defW]=index[3*((jsf[0][defW]|0)+1)+((jsf[1][defW]|0)+1)],naf[b][defW]=0,wnd[nafPoints]=comb}}points=this.jpoint(null,null,null);coeffs=this._wnafT4;for(i=max;0<=i;i--){for(max=0;0<=i;){wndWidth=!0;for(defW=0;defW<len;defW++)coeffs[defW]=naf[defW][i]|0,0!==coeffs[defW]&&(wndWidth=!1);if(!wndWidth)break;max++;
i--}0<=i&&max++;points=points.dblp(max);if(0>i)break;for(defW=0;defW<len;defW++)max=coeffs[defW],0!==max&&(0<max?p=wnd[defW][max-1>>1]:0>max&&(p=wnd[defW][-max-1>>1].neg()),points="affine"===p.type?points.mixedAdd(p):points.add(p))}for(i=0;i<len;i++)wnd[i]=null;return jacobianResult?points:points.toP()};BaseCurve.BasePoint=BasePoint;BasePoint.prototype.eq=function(){throw Error("Not implemented");};BasePoint.prototype.validate=function(){return this.curve.validate(this)};BaseCurve.prototype.decodePoint=
function(bytes,enc){bytes=utils.toArray(bytes,enc);enc=this.p.byteLength();if((4===bytes[0]||6===bytes[0]||7===bytes[0])&&bytes.length-1===2*enc)return 6===bytes[0]?assert(0===bytes[bytes.length-1]%2):7===bytes[0]&&assert(1===bytes[bytes.length-1]%2),this.point(bytes.slice(1,1+enc),bytes.slice(1+enc,1+2*enc));if((2===bytes[0]||3===bytes[0])&&bytes.length-1===enc)return this.pointFromX(bytes.slice(1,1+enc),3===bytes[0]);throw Error("Unknown point format");};BasePoint.prototype.encodeCompressed=function(enc){return this.encode(enc,
!0)};BasePoint.prototype._encode=function(compact){var len=this.curve.p.byteLength(),x=this.getX().toArray("be",len);return compact?[this.getY().isEven()?2:3].concat(x):[4].concat(x,this.getY().toArray("be",len))};BasePoint.prototype.encode=function(enc,compact){return utils.encode(this._encode(compact),enc)};BasePoint.prototype.precompute=function(power){if(this.precomputed)return this;var precomputed={doubles:null,naf:null,beta:null};precomputed.naf=this._getNAFPoints(8);precomputed.doubles=this._getDoubles(4,
power);precomputed.beta=this._getBeta();this.precomputed=precomputed;return this};BasePoint.prototype._hasDoubles=function(k){if(!this.precomputed)return!1;var doubles=this.precomputed.doubles;return doubles?doubles.points.length>=Math.ceil((k.bitLength()+1)/doubles.step):!1};BasePoint.prototype._getDoubles=function(step,power){if(this.precomputed&&this.precomputed.doubles)return this.precomputed.doubles;for(var doubles=[this],acc=this,i=0;i<power;i+=step){for(var j=0;j<step;j++)acc=acc.dbl();doubles.push(acc)}return{step:step,
points:doubles}};BasePoint.prototype._getNAFPoints=function(wnd){if(this.precomputed&&this.precomputed.naf)return this.precomputed.naf;for(var res=[this],max=(1<<wnd)-1,dbl=1===max?null:this.dbl(),i=1;i<max;i++)res[i]=res[i-1].add(dbl);return{wnd:wnd,points:res}};BasePoint.prototype._getBeta=function(){return null};BasePoint.prototype.dblp=function(k){for(var r=this,i=0;i<k;i++)r=r.dbl();return r}}
//# sourceMappingURL=module$node_modules$elliptic$lib$elliptic$curve$base.js.map
