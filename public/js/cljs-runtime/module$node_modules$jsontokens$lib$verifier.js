shadow$provide.module$node_modules$jsontokens$lib$verifier=function(global,process,require,module,exports,shadow$shims){Object.defineProperty(exports,"__esModule",{value:!0});exports.TokenVerifier=void 0;var _typeof="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_createClass=function(){function defineProperties(target,props){for(var i=
0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;"value"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){protoProps&&defineProperties(Constructor.prototype,protoProps);staticProps&&defineProperties(Constructor,staticProps);return Constructor}}(),_base64url2=(global=require("module$node_modules$base64url$index"))&&global.__esModule?
global:{default:global},_cryptoClients=require("module$node_modules$jsontokens$lib$cryptoClients$index");require("module$node_modules$jsontokens$lib$decode");exports.TokenVerifier=function(){function TokenVerifier(signingAlgorithm,rawPublicKey){if(!(this instanceof TokenVerifier))throw new TypeError("Cannot call a class as a function");if(!signingAlgorithm||!rawPublicKey)throw new MissingParametersError("a signing algorithm and public key are required");if("string"!==typeof signingAlgorithm)throw"signing algorithm parameter must be a string";
signingAlgorithm=signingAlgorithm.toUpperCase();if(!_cryptoClients.cryptoClients.hasOwnProperty(signingAlgorithm))throw"invalid signing algorithm";this.tokenType="JWT";this.cryptoClient=_cryptoClients.cryptoClients[signingAlgorithm];this.rawPublicKey=rawPublicKey}_createClass(TokenVerifier,[{key:"verify",value:function(token){return"string"===typeof token?this.verifyCompact(token):"object"===("undefined"===typeof token?"undefined":_typeof(token))?this.verifyExpanded(token):!1}},{key:"verifyCompact",
value:function(token){var tokenParts=token.split(".");token=this.cryptoClient.createHash(tokenParts[0]+"."+tokenParts[1]);tokenParts=this.cryptoClient.loadSignature(tokenParts[2]);return this.cryptoClient.verifyHash(token,tokenParts,this.rawPublicKey)}},{key:"verifyExpanded",value:function(token){var _this=this,signingInput=[token.header.join("."),_base64url2.default.encode(token.payload)].join("."),signingInputHash=this.cryptoClient.createHash(signingInput),verified=!0;token.signature.map(function(signature){signature=
_this.cryptoClient.loadSignature(signature);_this.cryptoClient.verifyHash(signingInputHash,signature,_this.rawPublicKey)||(verified=!1)});return verified}}]);return TokenVerifier}()}
//# sourceMappingURL=module$node_modules$jsontokens$lib$verifier.js.map
