{
"version":3,
"file":"module$node_modules$bitcoinjs_lib$src$block.js",
"lineCount":8,
"mappings":"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",
"sources":["node_modules/bitcoinjs-lib/src/block.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$bitcoinjs_lib$src$block\"] = function(global,process,require,module,exports,shadow$shims) {\nconst Buffer = require('safe-buffer').Buffer\nconst bcrypto = require('./crypto')\nconst fastMerkleRoot = require('merkle-lib/fastRoot')\nconst typeforce = require('typeforce')\nconst types = require('./types')\nconst varuint = require('varuint-bitcoin')\n\nconst Transaction = require('./transaction')\n\nfunction Block () {\n  this.version = 1\n  this.prevHash = null\n  this.merkleRoot = null\n  this.timestamp = 0\n  this.bits = 0\n  this.nonce = 0\n}\n\nBlock.fromBuffer = function (buffer) {\n  if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)')\n\n  let offset = 0\n  function readSlice (n) {\n    offset += n\n    return buffer.slice(offset - n, offset)\n  }\n\n  function readUInt32 () {\n    const i = buffer.readUInt32LE(offset)\n    offset += 4\n    return i\n  }\n\n  function readInt32 () {\n    const i = buffer.readInt32LE(offset)\n    offset += 4\n    return i\n  }\n\n  const block = new Block()\n  block.version = readInt32()\n  block.prevHash = readSlice(32)\n  block.merkleRoot = readSlice(32)\n  block.timestamp = readUInt32()\n  block.bits = readUInt32()\n  block.nonce = readUInt32()\n\n  if (buffer.length === 80) return block\n\n  function readVarInt () {\n    const vi = varuint.decode(buffer, offset)\n    offset += varuint.decode.bytes\n    return vi\n  }\n\n  function readTransaction () {\n    const tx = Transaction.fromBuffer(buffer.slice(offset), true)\n    offset += tx.byteLength()\n    return tx\n  }\n\n  const nTransactions = readVarInt()\n  block.transactions = []\n\n  for (var i = 0; i < nTransactions; ++i) {\n    const tx = readTransaction()\n    block.transactions.push(tx)\n  }\n\n  return block\n}\n\nBlock.prototype.byteLength = function (headersOnly) {\n  if (headersOnly || !this.transactions) return 80\n\n  return 80 + varuint.encodingLength(this.transactions.length) + this.transactions.reduce(function (a, x) {\n    return a + x.byteLength()\n  }, 0)\n}\n\nBlock.fromHex = function (hex) {\n  return Block.fromBuffer(Buffer.from(hex, 'hex'))\n}\n\nBlock.prototype.getHash = function () {\n  return bcrypto.hash256(this.toBuffer(true))\n}\n\nBlock.prototype.getId = function () {\n  return this.getHash().reverse().toString('hex')\n}\n\nBlock.prototype.getUTCDate = function () {\n  const date = new Date(0) // epoch\n  date.setUTCSeconds(this.timestamp)\n\n  return date\n}\n\n// TODO: buffer, offset compatibility\nBlock.prototype.toBuffer = function (headersOnly) {\n  const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly))\n\n  let offset = 0\n  function writeSlice (slice) {\n    slice.copy(buffer, offset)\n    offset += slice.length\n  }\n\n  function writeInt32 (i) {\n    buffer.writeInt32LE(i, offset)\n    offset += 4\n  }\n  function writeUInt32 (i) {\n    buffer.writeUInt32LE(i, offset)\n    offset += 4\n  }\n\n  writeInt32(this.version)\n  writeSlice(this.prevHash)\n  writeSlice(this.merkleRoot)\n  writeUInt32(this.timestamp)\n  writeUInt32(this.bits)\n  writeUInt32(this.nonce)\n\n  if (headersOnly || !this.transactions) return buffer\n\n  varuint.encode(this.transactions.length, buffer, offset)\n  offset += varuint.encode.bytes\n\n  this.transactions.forEach(function (tx) {\n    const txSize = tx.byteLength() // TODO: extract from toBuffer?\n    tx.toBuffer(buffer, offset)\n    offset += txSize\n  })\n\n  return buffer\n}\n\nBlock.prototype.toHex = function (headersOnly) {\n  return this.toBuffer(headersOnly).toString('hex')\n}\n\nBlock.calculateTarget = function (bits) {\n  const exponent = ((bits & 0xff000000) >> 24) - 3\n  const mantissa = bits & 0x007fffff\n  const target = Buffer.alloc(32, 0)\n  target.writeUInt32BE(mantissa, 28 - exponent)\n  return target\n}\n\nBlock.calculateMerkleRoot = function (transactions) {\n  typeforce([{ getHash: types.Function }], transactions)\n  if (transactions.length === 0) throw TypeError('Cannot compute merkle root for zero transactions')\n\n  const hashes = transactions.map(function (transaction) {\n    return transaction.getHash()\n  })\n\n  return fastMerkleRoot(hashes, bcrypto.hash256)\n}\n\nBlock.prototype.checkMerkleRoot = function () {\n  if (!this.transactions) return false\n\n  const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions)\n  return this.merkleRoot.compare(actualMerkleRoot) === 0\n}\n\nBlock.prototype.checkProofOfWork = function () {\n  const hash = this.getHash().reverse()\n  const target = Block.calculateTarget(this.bits)\n\n  return hash.compare(target) <= 0\n}\n\nmodule.exports = Block\n\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","Block","version","merkleRoot","prevHash","nonce","bits","timestamp","Buffer","bcrypto","fastMerkleRoot","typeforce","types","varuint","Transaction","fromBuffer","Block.fromBuffer","buffer","readSlice","n","offset","slice","readUInt32","i","readUInt32LE","readTransaction","tx","byteLength","length","Error","block","readInt32","readInt32LE","nTransactions","readVarInt","vi","decode","bytes","transactions","push","prototype","Block.prototype.byteLength","headersOnly","encodingLength","reduce","a","x","fromHex","Block.fromHex","hex","from","getHash","Block.prototype.getHash","hash256","toBuffer","getId","Block.prototype.getId","reverse","toString","getUTCDate","Block.prototype.getUTCDate","date","Date","setUTCSeconds","Block.prototype.toBuffer","writeSlice","copy","writeUInt32","writeUInt32LE","allocUnsafe","writeInt32LE","encode","forEach","txSize","toHex","Block.prototype.toHex","calculateTarget","Block.calculateTarget","exponent","mantissa","target","alloc","writeUInt32BE","calculateMerkleRoot","Block.calculateMerkleRoot","Function","TypeError","hashes","map","transaction","checkMerkleRoot","Block.prototype.checkMerkleRoot","actualMerkleRoot","compare","checkProofOfWork","Block.prototype.checkProofOfWork","hash"]
}
