shadow$provide.module$node_modules$elliptic$lib$elliptic$curve$edwards=function(global,process,require,module,exports,shadow$shims){function EdwardsCurve(conf){this.extended=this.mOneA=(this.twisted=1!==(conf.a|0))&&-1===(conf.a|0);Base.call(this,"edwards",conf);this.a=(new BN(conf.a,16)).umod(this.red.m);this.a=this.a.toRed(this.red);this.c=(new BN(conf.c,16)).toRed(this.red);this.c2=this.c.redSqr();this.d=(new BN(conf.d,16)).toRed(this.red);this.dd=this.d.redAdd(this.d);assert(!this.twisted||0===
this.c.fromRed().cmpn(1));this.oneC=1===(conf.c|0)}function Point(curve,x,y,z,t){Base.BasePoint.call(this,curve,"projective");null===x&&null===y&&null===z?(this.x=this.curve.zero,this.z=this.y=this.curve.one,this.t=this.curve.zero,this.zOne=!0):(this.x=new BN(x,16),this.y=new BN(y,16),this.z=z?new BN(z,16):this.curve.one,this.t=t&&new BN(t,16),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)),this.t&&
!this.t.red&&(this.t=this.t.toRed(this.curve.red)),this.zOne=this.z===this.curve.one,this.curve.extended&&!this.t&&(this.t=this.x.redMul(this.y),this.zOne||(this.t=this.t.redMul(this.z.redInvm()))))}global=require("module$node_modules$elliptic$lib$elliptic$curve$index");process=require("module$node_modules$elliptic$lib$elliptic");var BN=require("module$node_modules$bn_DOT_js$lib$bn");require=require("module$node_modules$inherits$inherits_browser");var Base=global.base,assert=process.utils.assert;
require(EdwardsCurve,Base);module.exports=EdwardsCurve;EdwardsCurve.prototype._mulA=function(num){return this.mOneA?num.redNeg():this.a.redMul(num)};EdwardsCurve.prototype._mulC=function(num){return this.oneC?num:this.c.redMul(num)};EdwardsCurve.prototype.jpoint=function(x,y,z,t){return this.point(x,y,z,t)};EdwardsCurve.prototype.pointFromX=function(x,odd){x=new BN(x,16);x.red||(x=x.toRed(this.red));var x2=x.redSqr(),rhs=this.c2.redSub(this.a.redMul(x2));x2=this.one.redSub(this.c2.redMul(this.d).redMul(x2));
x2=rhs.redMul(x2.redInvm());rhs=x2.redSqrt();if(0!==rhs.redSqr().redSub(x2).cmp(this.zero))throw Error("invalid point");x2=rhs.fromRed().isOdd();if(odd&&!x2||!odd&&x2)rhs=rhs.redNeg();return this.point(x,rhs)};EdwardsCurve.prototype.pointFromY=function(y,odd){y=new BN(y,16);y.red||(y=y.toRed(this.red));var y2=y.redSqr(),lhs=y2.redSub(this.c2);y2=y2.redMul(this.d).redMul(this.c2).redSub(this.a);lhs=lhs.redMul(y2.redInvm());if(0===lhs.cmp(this.zero)){if(odd)throw Error("invalid point");return this.point(this.zero,
y)}y2=lhs.redSqrt();if(0!==y2.redSqr().redSub(lhs).cmp(this.zero))throw Error("invalid point");y2.fromRed().isOdd()!==odd&&(y2=y2.redNeg());return this.point(y2,y)};EdwardsCurve.prototype.validate=function(point){if(point.isInfinity())return!0;point.normalize();var x2=point.x.redSqr(),y2=point.y.redSqr();point=x2.redMul(this.a).redAdd(y2);x2=this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));return 0===point.cmp(x2)};require(Point,Base.BasePoint);EdwardsCurve.prototype.pointFromJSON=function(obj){return Point.fromJSON(this,
obj)};EdwardsCurve.prototype.point=function(x,y,z,t){return new Point(this,x,y,z,t)};Point.fromJSON=function(curve,obj){return new Point(curve,obj[0],obj[1],obj[2])};Point.prototype.inspect=function(){return this.isInfinity()?"\x3cEC Point Infinity\x3e":"\x3cEC Point x: "+this.x.fromRed().toString(16,2)+" y: "+this.y.fromRed().toString(16,2)+" z: "+this.z.fromRed().toString(16,2)+"\x3e"};Point.prototype.isInfinity=function(){return 0===this.x.cmpn(0)&&(0===this.y.cmp(this.z)||this.zOne&&0===this.y.cmp(this.curve.c))};
Point.prototype._extDbl=function(){var a=this.x.redSqr(),b=this.y.redSqr(),c=this.z.redSqr();c=c.redIAdd(c);var d=this.curve._mulA(a),e=this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);a=d.redAdd(b);c=a.redSub(c);var h=d.redSub(b);b=e.redMul(c);d=a.redMul(h);e=e.redMul(h);a=c.redMul(a);return this.curve.point(b,d,a,e)};Point.prototype._projDbl=function(){var b=this.x.redAdd(this.y).redSqr(),c=this.x.redSqr(),d=this.y.redSqr();if(this.curve.twisted){var nz=this.curve._mulA(c);var f=nz.redAdd(d);
if(this.zOne)b=b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two)),c=f.redMul(nz.redSub(d)),nz=f.redSqr().redSub(f).redSub(f);else{var h=this.z.redSqr();h=f.redSub(h).redISub(h);b=b.redSub(c).redISub(d).redMul(h);c=f.redMul(nz.redSub(d));nz=f.redMul(h)}}else nz=c.redAdd(d),h=this.curve._mulC(this.z).redSqr(),h=nz.redSub(h).redSub(h),b=this.curve._mulC(b.redISub(nz)).redMul(h),c=this.curve._mulC(nz).redMul(c.redISub(d)),nz=nz.redMul(h);return this.curve.point(b,c,nz)};Point.prototype.dbl=function(){return this.isInfinity()?
this:this.curve.extended?this._extDbl():this._projDbl()};Point.prototype._extAdd=function(p){var a=this.y.redSub(this.x).redMul(p.y.redSub(p.x)),b=this.y.redAdd(this.x).redMul(p.y.redAdd(p.x)),c=this.t.redMul(this.curve.dd).redMul(p.t),d=this.z.redMul(p.z.redAdd(p.z)),e=b.redSub(a);p=d.redSub(c);c=d.redAdd(c);d=b.redAdd(a);a=e.redMul(p);b=c.redMul(d);e=e.redMul(d);p=p.redMul(c);return this.curve.point(a,b,p,e)};Point.prototype._projAdd=function(p){var a=this.z.redMul(p.z),b=a.redSqr(),c=this.x.redMul(p.x),
d=this.y.redMul(p.y),e=this.curve.d.redMul(c).redMul(d),f=b.redSub(e);b=b.redAdd(e);p=this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);p=a.redMul(f).redMul(p);this.curve.twisted?(a=a.redMul(b).redMul(d.redSub(this.curve._mulA(c))),f=f.redMul(b)):(a=a.redMul(b).redMul(d.redSub(c)),f=this.curve._mulC(f).redMul(b));return this.curve.point(p,a,f)};Point.prototype.add=function(p){return this.isInfinity()?p:p.isInfinity()?this:this.curve.extended?this._extAdd(p):this._projAdd(p)};Point.prototype.mul=
function(k){return this._hasDoubles(k)?this.curve._fixedNafMul(this,k):this.curve._wnafMul(this,k)};Point.prototype.mulAdd=function(k1,p,k2){return this.curve._wnafMulAdd(1,[this,p],[k1,k2],2,!1)};Point.prototype.jmulAdd=function(k1,p,k2){return this.curve._wnafMulAdd(1,[this,p],[k1,k2],2,!0)};Point.prototype.normalize=function(){if(this.zOne)return this;var zi=this.z.redInvm();this.x=this.x.redMul(zi);this.y=this.y.redMul(zi);this.t&&(this.t=this.t.redMul(zi));this.z=this.curve.one;this.zOne=!0;
return this};Point.prototype.neg=function(){return this.curve.point(this.x.redNeg(),this.y,this.z,this.t&&this.t.redNeg())};Point.prototype.getX=function(){this.normalize();return this.x.fromRed()};Point.prototype.getY=function(){this.normalize();return this.y.fromRed()};Point.prototype.eq=function(other){return this===other||0===this.getX().cmp(other.getX())&&0===this.getY().cmp(other.getY())};Point.prototype.eqXToP=function(x){var rx=x.toRed(this.curve.red).redMul(this.z);if(0===this.x.cmp(rx))return!0;
x=x.clone();for(var t=this.curve.redN.redMul(this.z);;){x.iadd(this.curve.n);if(0<=x.cmp(this.curve.p))return!1;rx.redIAdd(t);if(0===this.x.cmp(rx))return!0}};Point.prototype.toP=Point.prototype.normalize;Point.prototype.mixedAdd=Point.prototype.add}
//# sourceMappingURL=module$node_modules$elliptic$lib$elliptic$curve$edwards.js.map
