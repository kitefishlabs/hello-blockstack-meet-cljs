shadow$provide.module$node_modules$bitcoinjs_lib$src$payments$embed=function(global,process,require,module,exports,shadow$shims){function stacksEqual(a,b){return a.length!==b.length?!1:a.every(function(x,i){return x.equals(b[i])})}var lazy=require("module$node_modules$bitcoinjs_lib$src$payments$lazy"),typef=require("module$node_modules$typeforce$index"),OPS=require("module$node_modules$bitcoin_ops$index_json"),bscript=require("module$node_modules$bitcoinjs_lib$src$script"),BITCOIN_NETWORK=require("module$node_modules$bitcoinjs_lib$src$networks").bitcoin;
module.exports=function(a,opts){if(!a.data&&!a.output)throw new TypeError("Not enough data");opts=Object.assign({validate:!0},opts||{});typef({network:typef.maybe(typef.Object),output:typef.maybe(typef.Buffer),data:typef.maybe(typef.arrayOf(typef.Buffer))},a);var o={network:a.network||BITCOIN_NETWORK};lazy.prop(o,"output",function(){if(a.data)return bscript.compile([OPS.OP_RETURN].concat(a.data))});lazy.prop(o,"data",function(){if(a.output)return bscript.decompile(a.output).slice(1)});if(opts.validate&&
a.output){opts=bscript.decompile(a.output);if(opts[0]!==OPS.OP_RETURN)throw new TypeError("Output is invalid");if(!opts.slice(1).every(typef.Buffer))throw new TypeError("Output is invalid");if(a.data&&!stacksEqual(a.data,o.data))throw new TypeError("Data mismatch");}return Object.assign(o,a)}}
//# sourceMappingURL=module$node_modules$bitcoinjs_lib$src$payments$embed.js.map
