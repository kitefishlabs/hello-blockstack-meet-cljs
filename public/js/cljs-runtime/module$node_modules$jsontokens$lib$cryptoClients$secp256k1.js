shadow$provide.module$node_modules$jsontokens$lib$cryptoClients$secp256k1=function(global,process,require,module,exports,shadow$shims){Object.defineProperty(exports,"__esModule",{value:!0});exports.SECP256K1Client=void 0;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;"value"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,
descriptor)}}return function(Constructor,protoProps,staticProps){protoProps&&defineProperties(Constructor.prototype,protoProps);staticProps&&defineProperties(Constructor,staticProps);return Constructor}}();global=require("module$node_modules$elliptic$lib$elliptic");var _crypto=require("module$node_modules$crypto_browserify$index");process=(process=require("module$node_modules$key_encoder$index"))&&process.__esModule?process:{default:process};var _validator=require("module$node_modules$validator$index"),
_ecdsaSigFormatter=require("module$node_modules$jsontokens$lib$cryptoClients$ecdsaSigFormatter"),_errors=require("module$node_modules$jsontokens$lib$errors");require=exports.SECP256K1Client=function(){function SECP256K1Client(){if(!(this instanceof SECP256K1Client))throw new TypeError("Cannot call a class as a function");}_createClass(SECP256K1Client,null,[{key:"createHash",value:function(signingInput){return(0,_crypto.createHash)("sha256").update(signingInput).digest()}},{key:"loadPrivateKey",value:function(rawPrivateKey){66===
rawPrivateKey.length&&(rawPrivateKey=rawPrivateKey.slice(0,64));return SECP256K1Client.ec.keyFromPrivate(rawPrivateKey)}},{key:"loadPublicKey",value:function(rawPublicKey){return SECP256K1Client.ec.keyFromPublic(rawPublicKey,"hex")}},{key:"encodePublicKey",value:function(publicKey,originalFormat,destinationFormat){return SECP256K1Client.keyEncoder.encodePublic(publicKey,originalFormat,destinationFormat)}},{key:"derivePublicKey",value:function(privateKey,compressed){if("string"!==typeof privateKey)throw Error("private key must be a string");
if(!(0,_validator.isHexadecimal)(privateKey))throw Error("private key must be a hex string");if(66==privateKey.length)privateKey=privateKey.slice(0,64);else if(!(64>=privateKey.length))throw Error("private key must be 66 characters or less");void 0===compressed&&(compressed=!0);return SECP256K1Client.ec.keyFromPrivate(privateKey).getPublic(compressed,"hex")}},{key:"signHash",value:function(signingInputHash,rawPrivateKey){var format=2<arguments.length&&void 0!==arguments[2]?arguments[2]:"jose";if(!signingInputHash||
!rawPrivateKey)throw new _errors.MissingParametersError("a signing input hash and private key are all required");var signatureObject=SECP256K1Client.loadPrivateKey(rawPrivateKey).sign(signingInputHash);signatureObject=new shadow$shims.Buffer(signatureObject.toDER());if("der"===format)return signatureObject.toString("hex");if("jose"===format)return(0,_ecdsaSigFormatter.derToJose)(signatureObject,"ES256");throw Error("Invalid signature format");}},{key:"loadSignature",value:function(joseSignature){return(0,
_ecdsaSigFormatter.joseToDer)(joseSignature,"ES256")}},{key:"verifyHash",value:function(signingInputHash,derSignatureBuffer,rawPublicKey){if(!(signingInputHash&&derSignatureBuffer&&rawPublicKey))throw new _errors.MissingParametersError("a signing input hash, der signature, and public key are all required");return SECP256K1Client.loadPublicKey(rawPublicKey).verify(signingInputHash,derSignatureBuffer)}}]);return SECP256K1Client}();require.algorithmName="ES256K";require.ec=new global.ec("secp256k1");
require.keyEncoder=new process.default({curveParameters:[1,3,132,0,10],privatePEMOptions:{label:"EC PRIVATE KEY"},publicPEMOptions:{label:"PUBLIC KEY"},curve:require.ec})}
//# sourceMappingURL=module$node_modules$jsontokens$lib$cryptoClients$secp256k1.js.map
