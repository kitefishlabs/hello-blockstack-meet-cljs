shadow$provide.module$node_modules$key_encoder$lib$key_encoder=function(global,process,require,module,exports,shadow$shims){function KeyEncoder(options){if("string"===typeof options){if(!curves.hasOwnProperty(options))throw Error("Unknown curve "+options||"Assertion failed");options=curves[options]}this.options=options;this.algorithmID=[1,2,840,10045,2,1]}global=require("module$node_modules$asn1_DOT_js$lib$asn1");var BN=require("module$node_modules$bn_DOT_js$lib$bn");require=require("module$node_modules$elliptic$lib$elliptic").ec;
var ECPrivateKeyASN=global.define("ECPrivateKey",function(){this.seq().obj(this.key("version").int(),this.key("privateKey").octstr(),this.key("parameters").explicit(0).objid().optional(),this.key("publicKey").explicit(1).bitstr().optional())}),SubjectPublicKeyInfoASN=global.define("SubjectPublicKeyInfo",function(){this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(),this.key("curve").objid()),this.key("pub").bitstr())}),curves={secp256k1:{curveParameters:[1,3,132,0,10],privatePEMOptions:{label:"EC PRIVATE KEY"},
publicPEMOptions:{label:"PUBLIC KEY"},curve:new require("secp256k1")}};KeyEncoder.ECPrivateKeyASN=ECPrivateKeyASN;KeyEncoder.SubjectPublicKeyInfoASN=SubjectPublicKeyInfoASN;KeyEncoder.prototype.privateKeyObject=function(rawPrivateKey,rawPublicKey){rawPrivateKey={version:new BN(1),privateKey:new shadow$shims.Buffer(rawPrivateKey,"hex"),parameters:this.options.curveParameters};rawPublicKey&&(rawPrivateKey.publicKey={unused:0,data:new shadow$shims.Buffer(rawPublicKey,"hex")});return rawPrivateKey};KeyEncoder.prototype.publicKeyObject=
function(rawPublicKey){return{algorithm:{id:this.algorithmID,curve:this.options.curveParameters},pub:{unused:0,data:new shadow$shims.Buffer(rawPublicKey,"hex")}}};KeyEncoder.prototype.encodePrivate=function(privateKey,originalFormat,destinationFormat){if("raw"===originalFormat)originalFormat=this.options.curve.keyFromPrivate(privateKey,"hex"),originalFormat=originalFormat.getPublic("hex"),originalFormat=this.privateKeyObject(privateKey,originalFormat);else if("der"===originalFormat){if("buffer"!==
typeof privateKey)if("string"===typeof privateKey)privateKey=new shadow$shims.Buffer(privateKey,"hex");else throw"private key must be a buffer or a string";originalFormat=ECPrivateKeyASN.decode(privateKey,"der")}else if("pem"===originalFormat)originalFormat=ECPrivateKeyASN.decode(privateKey,"pem",this.options.privatePEMOptions);else throw"invalid private key format";if("raw"===destinationFormat)return originalFormat.privateKey.toString("hex");if("der"===destinationFormat)return ECPrivateKeyASN.encode(originalFormat,
"der").toString("hex");if("pem"===destinationFormat)return ECPrivateKeyASN.encode(originalFormat,"pem",this.options.privatePEMOptions);throw"invalid destination format for private key";};KeyEncoder.prototype.encodePublic=function(publicKey,originalFormat,destinationFormat){if("raw"===originalFormat)publicKey=this.publicKeyObject(publicKey);else if("der"===originalFormat){if("buffer"!==typeof publicKey)if("string"===typeof publicKey)publicKey=new shadow$shims.Buffer(publicKey,"hex");else throw"public key must be a buffer or a string";
publicKey=SubjectPublicKeyInfoASN.decode(publicKey,"der")}else if("pem"===originalFormat)publicKey=SubjectPublicKeyInfoASN.decode(publicKey,"pem",this.options.publicPEMOptions);else throw"invalid public key format";if("raw"===destinationFormat)return publicKey.pub.data.toString("hex");if("der"===destinationFormat)return SubjectPublicKeyInfoASN.encode(publicKey,"der").toString("hex");if("pem"===destinationFormat)return SubjectPublicKeyInfoASN.encode(publicKey,"pem",this.options.publicPEMOptions);throw"invalid destination format for public key";
};module.exports=KeyEncoder}
//# sourceMappingURL=module$node_modules$key_encoder$lib$key_encoder.js.map
