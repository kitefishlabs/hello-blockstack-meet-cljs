shadow$provide.module$node_modules$bitcoinjs_lib$src$script=function(global,process,require,module,exports,shadow$shims){function isPushOnlyChunk(value){var JSCompiler_temp;(JSCompiler_temp=types.Buffer(value))||(JSCompiler_temp=types.Number(value)&&(value===OPS.OP_0||value>=OPS.OP_1&&value<=OPS.OP_16||value===OPS.OP_1NEGATE));return JSCompiler_temp}function isPushOnly(value){return types.Array(value)&&value.every(isPushOnlyChunk)}function asMinimalOP(buffer){if(0===buffer.length)return OPS.OP_0;
if(1===buffer.length){if(1<=buffer[0]&&16>=buffer[0])return OP_INT_BASE+buffer[0];if(129===buffer[0])return OPS.OP_1NEGATE}}function compile(chunks){if(Buffer.isBuffer(chunks))return chunks;typeforce(types.Array,chunks);var bufferSize=chunks.reduce(function(accum,chunk){return Buffer.isBuffer(chunk)?1===chunk.length&&void 0!==asMinimalOP(chunk)?accum+1:accum+pushdata.encodingLength(chunk.length)+chunk.length:accum+1},0),buffer=Buffer.allocUnsafe(bufferSize),offset=0;chunks.forEach(function(chunk){if(Buffer.isBuffer(chunk)){var opcode=
asMinimalOP(chunk);void 0!==opcode?(buffer.writeUInt8(opcode,offset),offset+=1):(offset+=pushdata.encode(buffer,chunk.length,offset),chunk.copy(buffer,offset),offset+=chunk.length)}else buffer.writeUInt8(chunk,offset),offset+=1});if(offset!==buffer.length)throw Error("Could not decode chunks");return buffer}function decompile(buffer){if(types.Array(buffer))return buffer;typeforce(types.Buffer,buffer);for(var chunks=[],i=0;i<buffer.length;){var opcode=buffer[i];if(opcode>OPS.OP_0&&opcode<=OPS.OP_PUSHDATA4){var d=
pushdata.decode(buffer,i);if(null===d)return null;i+=d.size;if(i+d.number>buffer.length)return null;opcode=buffer.slice(i,i+d.number);i+=d.number;d=asMinimalOP(opcode);void 0!==d?chunks.push(d):chunks.push(opcode)}else chunks.push(opcode),i+=1}return chunks}function isDefinedHashType(hashType){hashType&=-129;return 0<hashType&&4>hashType}var Buffer=require("module$node_modules$safe_buffer$index").Buffer,bip66=require("module$node_modules$bip66$index"),ecc=require("module$node_modules$tiny_secp256k1$ecurve"),
pushdata=require("module$node_modules$pushdata_bitcoin$index"),typeforce=require("module$node_modules$typeforce$index"),types=require("module$node_modules$bitcoinjs_lib$src$types"),scriptNumber=require("module$node_modules$bitcoinjs_lib$src$script_number"),OPS=require("module$node_modules$bitcoin_ops$index_json"),REVERSE_OPS=require("module$node_modules$bitcoin_ops$map"),OP_INT_BASE=OPS.OP_RESERVED;module.exports={compile:compile,decompile:decompile,fromASM:function(asm){typeforce(types.String,asm);
return compile(asm.split(" ").map(function(chunkStr){if(void 0!==OPS[chunkStr])return OPS[chunkStr];typeforce(types.Hex,chunkStr);return Buffer.from(chunkStr,"hex")}))},toASM:function(chunks){Buffer.isBuffer(chunks)&&(chunks=decompile(chunks));return chunks.map(function(chunk){if(Buffer.isBuffer(chunk)){var op=asMinimalOP(chunk);if(void 0===op)return chunk.toString("hex");chunk=op}return REVERSE_OPS[chunk]}).join(" ")},toStack:function(chunks){chunks=decompile(chunks);typeforce(isPushOnly,chunks);
return chunks.map(function(op){return Buffer.isBuffer(op)?op:op===OPS.OP_0?Buffer.allocUnsafe(0):scriptNumber.encode(op-OP_INT_BASE)})},number:require("module$node_modules$bitcoinjs_lib$src$script_number"),signature:require("module$node_modules$bitcoinjs_lib$src$script_signature"),isCanonicalPubKey:function(buffer){return ecc.isPoint(buffer)},isCanonicalScriptSignature:function(buffer){return Buffer.isBuffer(buffer)&&isDefinedHashType(buffer[buffer.length-1])?bip66.check(buffer.slice(0,-1)):!1},isPushOnly:isPushOnly,
isDefinedHashType:isDefinedHashType}}
//# sourceMappingURL=module$node_modules$bitcoinjs_lib$src$script.js.map
