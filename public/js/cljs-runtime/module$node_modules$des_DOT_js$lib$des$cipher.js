shadow$provide.module$node_modules$des_DOT_js$lib$des$cipher=function(global,process,require,module,exports,shadow$shims){function Cipher(options){this.options=options;this.type=this.options.type;this.blockSize=8;this._init();this.buffer=Array(this.blockSize);this.bufferOff=0}var assert=require("module$node_modules$minimalistic_assert$index");module.exports=Cipher;Cipher.prototype._init=function(){};Cipher.prototype.update=function(data){return 0===data.length?[]:"decrypt"===this.type?this._updateDecrypt(data):
this._updateEncrypt(data)};Cipher.prototype._buffer=function(data,off){for(var min=Math.min(this.buffer.length-this.bufferOff,data.length-off),i=0;i<min;i++)this.buffer[this.bufferOff+i]=data[off+i];this.bufferOff+=min;return min};Cipher.prototype._flushBuffer=function(out,off){this._update(this.buffer,0,out,off);this.bufferOff=0;return this.blockSize};Cipher.prototype._updateEncrypt=function(data){var inputOff=0,outputOff=0,out=Array(((this.bufferOff+data.length)/this.blockSize|0)*this.blockSize);
0!==this.bufferOff&&(inputOff+=this._buffer(data,inputOff),this.bufferOff===this.buffer.length&&(outputOff+=this._flushBuffer(out,outputOff)));for(var max=data.length-(data.length-inputOff)%this.blockSize;inputOff<max;inputOff+=this.blockSize)this._update(data,inputOff,out,outputOff),outputOff+=this.blockSize;for(;inputOff<data.length;inputOff++,this.bufferOff++)this.buffer[this.bufferOff]=data[inputOff];return out};Cipher.prototype._updateDecrypt=function(data){for(var inputOff=0,outputOff=0,count=
Math.ceil((this.bufferOff+data.length)/this.blockSize)-1,out=Array(count*this.blockSize);0<count;count--)inputOff+=this._buffer(data,inputOff),outputOff+=this._flushBuffer(out,outputOff);this._buffer(data,inputOff);return out};Cipher.prototype.final=function(buffer){var first;buffer&&(first=this.update(buffer));buffer="encrypt"===this.type?this._finalEncrypt():this._finalDecrypt();return first?first.concat(buffer):buffer};Cipher.prototype._pad=function(buffer,off){if(0===off)return!1;for(;off<buffer.length;)buffer[off++]=
0;return!0};Cipher.prototype._finalEncrypt=function(){if(!this._pad(this.buffer,this.bufferOff))return[];var out=Array(this.blockSize);this._update(this.buffer,0,out,0);return out};Cipher.prototype._unpad=function(buffer){return buffer};Cipher.prototype._finalDecrypt=function(){assert.equal(this.bufferOff,this.blockSize,"Not enough data to decrypt");var out=Array(this.blockSize);this._flushBuffer(out,0);return this._unpad(out)}}
//# sourceMappingURL=module$node_modules$des_DOT_js$lib$des$cipher.js.map
