shadow$provide.module$node_modules$bip32$index=function(global,process,require,module,exports,shadow$shims){function BIP32(d,Q,chainCode,network){typeforce(NETWORK_TYPE,network);this.__d=d||null;this.__Q=Q||null;this.chainCode=chainCode;this.index=this.depth=0;this.network=network;this.parentFingerprint=0}function UInt31(value){return typeforce.UInt32(value)&&value<=UINT31_MAX}function BIP32Path(value){return typeforce.String(value)&&value.match(/^(m\/)?(\d+'?\/)*\d+'?$/)}function fromPrivateKey(privateKey,
chainCode,network){typeforce({privateKey:UINT256_TYPE,chainCode:UINT256_TYPE},{privateKey:privateKey,chainCode:chainCode});network=network||BITCOIN;if(!ecc.isPrivate(privateKey))throw new TypeError("Private key not in range [1, n)");return new BIP32(privateKey,null,chainCode,network)}function fromPublicKey(publicKey,chainCode,network){typeforce({publicKey:typeforce.BufferN(33),chainCode:UINT256_TYPE},{publicKey:publicKey,chainCode:chainCode});network=network||BITCOIN;if(!ecc.isPoint(publicKey))throw new TypeError("Point is not on the curve");
return new BIP32(null,publicKey,chainCode,network)}var Buffer=require("module$node_modules$safe_buffer$index").Buffer,bs58check=require("module$node_modules$bs58check$index"),crypto=require("module$node_modules$bip32$crypto"),ecc=require("module$node_modules$tiny_secp256k1$ecurve"),typeforce=require("module$node_modules$typeforce$index"),wif=require("module$node_modules$wif$index"),UINT256_TYPE=typeforce.BufferN(32),NETWORK_TYPE=typeforce.compile({wif:typeforce.UInt8,bip32:{public:typeforce.UInt32,
private:typeforce.UInt32}}),BITCOIN={wif:128,bip32:{public:76067358,private:76066276}};Object.defineProperty(BIP32.prototype,"identifier",{get:function(){return crypto.hash160(this.publicKey)}});Object.defineProperty(BIP32.prototype,"fingerprint",{get:function(){return this.identifier.slice(0,4)}});Object.defineProperty(BIP32.prototype,"privateKey",{enumerable:!1,get:function(){return this.__d}});Object.defineProperty(BIP32.prototype,"publicKey",{get:function(){this.__Q||(this.__Q=ecc.pointFromScalar(this.__d,
this.compressed));return this.__Q}});BIP32.prototype.isNeutered=function(){return null===this.__d};BIP32.prototype.neutered=function(){var neutered=fromPublicKey(this.publicKey,this.chainCode,this.network);neutered.depth=this.depth;neutered.index=this.index;neutered.parentFingerprint=this.parentFingerprint;return neutered};BIP32.prototype.toBase58=function(){var network=this.network;network=this.isNeutered()?network.bip32.public:network.bip32.private;var buffer=Buffer.allocUnsafe(78);buffer.writeUInt32BE(network,
0);buffer.writeUInt8(this.depth,4);buffer.writeUInt32BE(this.parentFingerprint,5);buffer.writeUInt32BE(this.index,9);this.chainCode.copy(buffer,13);this.isNeutered()?this.publicKey.copy(buffer,45):(buffer.writeUInt8(0,45),this.privateKey.copy(buffer,46));return bs58check.encode(buffer)};BIP32.prototype.toWIF=function(){if(!this.privateKey)throw new TypeError("Missing private key");return wif.encode(this.network.wif,this.privateKey,!0)};BIP32.prototype.derive=function(index){typeforce(typeforce.UInt32,
index);var isHardened=2147483648<=index,data=Buffer.allocUnsafe(37);if(isHardened){if(this.isNeutered())throw new TypeError("Missing private key for hardened child key");data[0]=0;this.privateKey.copy(data,1)}else this.publicKey.copy(data,0);data.writeUInt32BE(index,33);isHardened=crypto.hmacSHA512(this.chainCode,data);data=isHardened.slice(0,32);isHardened=isHardened.slice(32);if(!ecc.isPrivate(data))return this.derive(index+1);if(this.isNeutered()){data=ecc.pointAddScalar(this.publicKey,data,!0);
if(null===data)return this.derive(index+1);isHardened=fromPublicKey(data,isHardened,this.network)}else{data=ecc.privateAdd(this.privateKey,data);if(null==data)return this.derive(index+1);isHardened=fromPrivateKey(data,isHardened,this.network)}isHardened.depth=this.depth+1;isHardened.index=index;isHardened.parentFingerprint=this.fingerprint.readUInt32BE(0);return isHardened};var UINT31_MAX=Math.pow(2,31)-1;BIP32.prototype.deriveHardened=function(index){typeforce(UInt31,index);return this.derive(index+
2147483648)};BIP32.prototype.derivePath=function(path){typeforce(BIP32Path,path);path=path.split("/");if("m"===path[0]){if(this.parentFingerprint)throw new TypeError("Expected master, got child");path=path.slice(1)}return path.reduce(function(prevHd,indexStr){if("'"===indexStr.slice(-1))return indexStr=parseInt(indexStr.slice(0,-1),10),prevHd.deriveHardened(indexStr);indexStr=parseInt(indexStr,10);return prevHd.derive(indexStr)},this)};BIP32.prototype.sign=function(hash){return ecc.sign(hash,this.privateKey)};
BIP32.prototype.verify=function(hash,signature){return ecc.verify(hash,this.publicKey,signature)};module.exports={fromBase58:function(string,network){var buffer=bs58check.decode(string);if(78!==buffer.length)throw new TypeError("Invalid buffer length");network=network||BITCOIN;var version=buffer.readUInt32BE(0);if(version!==network.bip32.private&&version!==network.bip32.public)throw new TypeError("Invalid network version");string=buffer[4];var parentFingerprint=buffer.readUInt32BE(5);if(0===string&&
0!==parentFingerprint)throw new TypeError("Invalid parent fingerprint");var index=buffer.readUInt32BE(9);if(0===string&&0!==index)throw new TypeError("Invalid index");var chainCode=buffer.slice(13,45);if(version===network.bip32.private){if(0!==buffer.readUInt8(45))throw new TypeError("Invalid private key");buffer=buffer.slice(46,78);network=fromPrivateKey(buffer,chainCode,network)}else buffer=buffer.slice(45,78),network=fromPublicKey(buffer,chainCode,network);network.depth=string;network.index=index;
network.parentFingerprint=parentFingerprint;return network},fromPrivateKey:fromPrivateKey,fromPublicKey:fromPublicKey,fromSeed:function(seed,network){typeforce(typeforce.Buffer,seed);if(16>seed.length)throw new TypeError("Seed should be at least 128 bits");if(64<seed.length)throw new TypeError("Seed should be at most 512 bits");network=network||BITCOIN;var I=crypto.hmacSHA512("Bitcoin seed",seed);seed=I.slice(0,32);I=I.slice(32);return fromPrivateKey(seed,I,network)}}}
//# sourceMappingURL=module$node_modules$bip32$index.js.map
