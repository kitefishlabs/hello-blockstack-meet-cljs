shadow$provide.module$node_modules$bitcoinjs_lib$src$payments$p2pkh=function(global,process,require,module,exports,shadow$shims){var lazy=require("module$node_modules$bitcoinjs_lib$src$payments$lazy"),typef=require("module$node_modules$typeforce$index"),OPS=require("module$node_modules$bitcoin_ops$index_json"),ecc=require("module$node_modules$tiny_secp256k1$ecurve"),bcrypto=require("module$node_modules$bitcoinjs_lib$src$crypto"),bscript=require("module$node_modules$bitcoinjs_lib$src$script"),BITCOIN_NETWORK=
require("module$node_modules$bitcoinjs_lib$src$networks").bitcoin,bs58check=require("module$node_modules$bs58check$index");module.exports=function(a,opts){if(!(a.address||a.hash||a.output||a.pubkey||a.input))throw new TypeError("Not enough data");opts=Object.assign({validate:!0},opts||{});typef({network:typef.maybe(typef.Object),address:typef.maybe(typef.String),hash:typef.maybe(typef.BufferN(20)),output:typef.maybe(typef.BufferN(25)),pubkey:typef.maybe(ecc.isPoint),signature:typef.maybe(bscript.isCanonicalScriptSignature),
input:typef.maybe(typef.Buffer)},a);var _address=lazy.value(function(){var payload=bs58check.decode(a.address),version=payload.readUInt8(0);payload=payload.slice(1);return{version:version,hash:payload}}),_chunks=lazy.value(function(){return bscript.decompile(a.input)}),network=a.network||BITCOIN_NETWORK,o={network:network};lazy.prop(o,"address",function(){if(o.hash){var payload=shadow$shims.Buffer.allocUnsafe(21);payload.writeUInt8(network.pubKeyHash,0);o.hash.copy(payload,1);return bs58check.encode(payload)}});
lazy.prop(o,"hash",function(){if(a.output)return a.output.slice(3,23);if(a.address)return _address().hash;if(a.pubkey||o.pubkey)return bcrypto.hash160(a.pubkey||o.pubkey)});lazy.prop(o,"output",function(){if(o.hash)return bscript.compile([OPS.OP_DUP,OPS.OP_HASH160,o.hash,OPS.OP_EQUALVERIFY,OPS.OP_CHECKSIG])});lazy.prop(o,"pubkey",function(){if(a.input)return _chunks()[1]});lazy.prop(o,"signature",function(){if(a.input)return _chunks()[0]});lazy.prop(o,"input",function(){if(a.pubkey&&a.signature)return bscript.compile([a.signature,
a.pubkey])});lazy.prop(o,"witness",function(){if(o.input)return[]});if(opts.validate){if(a.address){if(_address().version!==network.pubKeyHash)throw new TypeError("Invalid version or Network mismatch");if(20!==_address().hash.length)throw new TypeError("Invalid address");var hash=_address().hash}if(a.hash){if(hash&&!hash.equals(a.hash))throw new TypeError("Hash mismatch");hash=a.hash}if(a.output){if(25!==a.output.length||a.output[0]!==OPS.OP_DUP||a.output[1]!==OPS.OP_HASH160||20!==a.output[2]||a.output[23]!==
OPS.OP_EQUALVERIFY||a.output[24]!==OPS.OP_CHECKSIG)throw new TypeError("Output is invalid");opts=a.output.slice(3,23);if(hash&&!hash.equals(opts))throw new TypeError("Hash mismatch");hash=opts}if(a.pubkey){opts=bcrypto.hash160(a.pubkey);if(hash&&!hash.equals(opts))throw new TypeError("Hash mismatch");hash=opts}if(a.input){opts=_chunks();if(2!==opts.length)throw new TypeError("Input is invalid");if(!bscript.isCanonicalScriptSignature(opts[0]))throw new TypeError("Input has invalid signature");if(!ecc.isPoint(opts[1]))throw new TypeError("Input has invalid pubkey");
if(a.signature&&!a.signature.equals(opts[0]))throw new TypeError("Signature mismatch");if(a.pubkey&&!a.pubkey.equals(opts[1]))throw new TypeError("Pubkey mismatch");opts=bcrypto.hash160(opts[1]);if(hash&&!hash.equals(opts))throw new TypeError("Hash mismatch");}}return Object.assign(o,a)}}
//# sourceMappingURL=module$node_modules$bitcoinjs_lib$src$payments$p2pkh.js.map
