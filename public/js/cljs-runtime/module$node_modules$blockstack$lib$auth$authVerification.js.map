{
"version":3,
"file":"module$node_modules$blockstack$lib$auth$authVerification.js",
"lineCount":8,
"mappings":"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",
"sources":["node_modules/blockstack/lib/auth/authVerification.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$blockstack$lib$auth$authVerification\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.doSignaturesMatchPublicKeys = doSignaturesMatchPublicKeys;\nexports.doPublicKeysMatchIssuer = doPublicKeysMatchIssuer;\nexports.doPublicKeysMatchUsername = doPublicKeysMatchUsername;\nexports.isIssuanceDateValid = isIssuanceDateValid;\nexports.isExpirationDateValid = isExpirationDateValid;\nexports.isManifestUriValid = isManifestUriValid;\nexports.isRedirectUriValid = isRedirectUriValid;\nexports.verifyAuthRequest = verifyAuthRequest;\nexports.verifyAuthRequestAndLoadManifest = verifyAuthRequestAndLoadManifest;\nexports.verifyAuthResponse = verifyAuthResponse;\n\nvar _jsontokens = require('jsontokens');\n\nvar _index = require('../index');\n\n/**\n * Checks if the ES256k signature on passed `token` match the claimed public key\n * in the payload key `public_keys`.\n *\n * @param  {String} token encoded and signed authentication token\n * @return {Boolean} Returns `true` if the signature matches the claimed public key\n * @throws {Error} if `token` contains multiple public keys\n * @private\n */\nfunction doSignaturesMatchPublicKeys(token) {\n  var payload = (0, _jsontokens.decodeToken)(token).payload;\n  var publicKeys = payload.public_keys;\n  if (publicKeys.length === 1) {\n    var publicKey = publicKeys[0];\n    try {\n      var tokenVerifier = new _jsontokens.TokenVerifier('ES256k', publicKey);\n      var signatureVerified = tokenVerifier.verify(token);\n      if (signatureVerified) {\n        return true;\n      } else {\n        return false;\n      }\n    } catch (e) {\n      return false;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n}\n\n/**\n * Makes sure that the identity address portion of\n * the decentralized identifier passed in the issuer `iss`\n * key of the token matches the public key\n *\n * @param  {String} token encoded and signed authentication token\n * @return {Boolean} if the identity address and public keys match\n * @throws {Error} if ` token` has multiple public keys\n * @private\n */\nfunction doPublicKeysMatchIssuer(token) {\n  var payload = (0, _jsontokens.decodeToken)(token).payload;\n  var publicKeys = payload.public_keys;\n  var addressFromIssuer = (0, _index.getAddressFromDID)(payload.iss);\n\n  if (publicKeys.length === 1) {\n    var addressFromPublicKeys = (0, _index.publicKeyToAddress)(publicKeys[0]);\n    if (addressFromPublicKeys === addressFromIssuer) {\n      return true;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n\n  return false;\n}\n\n/**\n * Looks up the identity address that owns the claimed username\n * in `token` using the lookup endpoint provided in `nameLookupURL`\n * to determine if the username is owned by the identity address\n * that matches the claimed public key\n *\n * @param  {String} token  encoded and signed authentication token\n * @param  {String} nameLookupURL a URL to the name lookup endpoint of the Blockstack Core API\n * @return {Promise<Boolean>} returns a `Promise` that resolves to\n * `true` if the username is owned by the public key, otherwise the\n * `Promise` resolves to `false`\n * @private\n */\nfunction doPublicKeysMatchUsername(token, nameLookupURL) {\n  return new Promise(function (resolve) {\n    var payload = (0, _jsontokens.decodeToken)(token).payload;\n\n    if (!payload.username) {\n      resolve(true);\n      return;\n    }\n\n    if (payload.username === null) {\n      resolve(true);\n      return;\n    }\n\n    if (nameLookupURL === null) {\n      resolve(false);\n      return;\n    }\n\n    var username = payload.username;\n    var url = nameLookupURL.replace(/\\/$/, '') + '/' + username;\n\n    try {\n      fetch(url).then(function (response) {\n        return response.text();\n      }).then(function (responseText) {\n        return JSON.parse(responseText);\n      }).then(function (responseJSON) {\n        if (responseJSON.hasOwnProperty('address')) {\n          var nameOwningAddress = responseJSON.address;\n          var addressFromIssuer = (0, _index.getAddressFromDID)(payload.iss);\n          if (nameOwningAddress === addressFromIssuer) {\n            resolve(true);\n          } else {\n            resolve(false);\n          }\n        } else {\n          resolve(false);\n        }\n      }).catch(function () {\n        resolve(false);\n      });\n    } catch (e) {\n      resolve(false);\n    }\n  });\n}\n\n/**\n * Checks if the if the token issuance time and date is after the\n * current time and date.\n *\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if the token was issued after the current time,\n * otherwise returns `false`\n * @private\n */\nfunction isIssuanceDateValid(token) {\n  var payload = (0, _jsontokens.decodeToken)(token).payload;\n  if (payload.iat) {\n    if (typeof payload.iat !== 'number') {\n      return false;\n    }\n    var issuedAt = new Date(payload.iat * 1000); // JWT times are in seconds\n    if (new Date().getTime() < issuedAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\n\n/**\n * Checks if the expiration date of the `token` is before the current time\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if the `token` has not yet expired, `false`\n * if the `token` has expired\n *\n * @private\n */\nfunction isExpirationDateValid(token) {\n  var payload = (0, _jsontokens.decodeToken)(token).payload;\n  if (payload.exp) {\n    if (typeof payload.exp !== 'number') {\n      return false;\n    }\n    var expiresAt = new Date(payload.exp * 1000); // JWT times are in seconds\n    if (new Date().getTime() > expiresAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\n\n/**\n * Makes sure the `manifest_uri` is a same origin absolute URL.\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if valid, otherwise `false`\n * @private\n */\nfunction isManifestUriValid(token) {\n  var payload = (0, _jsontokens.decodeToken)(token).payload;\n  return (0, _index.isSameOriginAbsoluteUrl)(payload.domain_name, payload.manifest_uri);\n}\n\n/**\n * Makes sure the `redirect_uri` is a same origin absolute URL.\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if valid, otherwise `false`\n * @private\n */\nfunction isRedirectUriValid(token) {\n  var payload = (0, _jsontokens.decodeToken)(token).payload;\n  return (0, _index.isSameOriginAbsoluteUrl)(payload.domain_name, payload.redirect_uri);\n}\n\n/**\n * Verify authentication request is valid. This function performs a number\n * of checks on the authentication request token:\n * * Checks that `token` has a valid issuance date & is not expired\n * * Checks that `token` has a valid signature that matches the public key it claims\n * * Checks that both the manifest and redirect URLs are absolute and conform to\n * the same origin policy\n *\n * @param  {String} token encoded and signed authentication request token\n * @return {Promise} that resolves to true if the auth request\n *  is valid and false if it does not. It rejects with a String if the\n *  token is not signed\n *  @private\n */\nfunction verifyAuthRequest(token) {\n  return new Promise(function (resolve, reject) {\n    if ((0, _jsontokens.decodeToken)(token).header.alg === 'none') {\n      reject('Token must be signed in order to be verified');\n    }\n\n    Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token), isManifestUriValid(token), isRedirectUriValid(token)]).then(function (values) {\n      if (values.every(Boolean)) {\n        resolve(true);\n      } else {\n        resolve(false);\n      }\n    });\n  });\n}\n\n/**\n * Verify the authentication request is valid and\n * fetch the app manifest file if valid. Otherwise, reject the promise.\n * @param  {String} token encoded and signed authentication request token\n * @return {Promise} that resolves to the app manifest file in JSON format\n * or rejects if the auth request or app manifest file is invalid\n * @private\n */\nfunction verifyAuthRequestAndLoadManifest(token) {\n  return new Promise(function (resolve, reject) {\n    return verifyAuthRequest(token).then(function (valid) {\n      if (valid) {\n        return (0, _index.fetchAppManifest)(token).then(function (appManifest) {\n          resolve(appManifest);\n        }).catch(function (err) {\n          reject(err);\n        });\n      } else {\n        reject();\n        return Promise.reject();\n      }\n    });\n  });\n}\n\n/**\n * Verify the authentication response is valid\n * @param {String} token the authentication response token\n * @param {String} nameLookupURL the url use to verify owner of a username\n * @return {Promise} that resolves to true if auth response\n * is valid and false if it does not\n * @private\n */\nfunction verifyAuthResponse(token, nameLookupURL) {\n  return new Promise(function (resolve) {\n    Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token), doPublicKeysMatchUsername(token, nameLookupURL)]).then(function (values) {\n      if (values.every(Boolean)) {\n        resolve(true);\n      } else {\n        resolve(false);\n      }\n    });\n  });\n}\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","doSignaturesMatchPublicKeys","token","publicKeys","_jsontokens","decodeToken","payload","public_keys","length","publicKey","verify","tokenVerifier","TokenVerifier","signatureVerified","e","Error","doPublicKeysMatchIssuer","addressFromIssuer","_index","getAddressFromDID","iss","addressFromPublicKeys","publicKeyToAddress","doPublicKeysMatchUsername","nameLookupURL","Promise","resolve","username","url","replace","fetch","then","response","text","responseText","JSON","parse","responseJSON","hasOwnProperty","nameOwningAddress","address","catch","isIssuanceDateValid","iat","issuedAt","Date","getTime","isExpirationDateValid","exp","expiresAt","isManifestUriValid","isSameOriginAbsoluteUrl","domain_name","manifest_uri","isRedirectUriValid","redirect_uri","verifyAuthRequest","reject","header","alg","all","values","every","Boolean","Object","defineProperty","value","verifyAuthRequestAndLoadManifest","valid","fetchAppManifest","appManifest","err","verifyAuthResponse"]
}
