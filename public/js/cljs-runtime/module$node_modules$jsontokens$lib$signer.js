shadow$provide.module$node_modules$jsontokens$lib$signer=function(global,process,require,module,exports,shadow$shims){function createSigningInput(payload,header){var tokenParts=[];header=_base64url2.default.encode(JSON.stringify(header));tokenParts.push(header);payload=_base64url2.default.encode(JSON.stringify(payload));tokenParts.push(payload);return tokenParts.join(".")}Object.defineProperty(exports,"__esModule",{value:!0});exports.TokenSigner=void 0;var _createClass=function(){function defineProperties(target,
props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;"value"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){protoProps&&defineProperties(Constructor.prototype,protoProps);staticProps&&defineProperties(Constructor,staticProps);return Constructor}}();exports.createUnsecuredToken=function(payload){return createSigningInput(payload,
{typ:"JWT",alg:"none"})+"."};var _base64url2=(global=require("module$node_modules$base64url$index"))&&global.__esModule?global:{default:global},_cryptoClients=require("module$node_modules$jsontokens$lib$cryptoClients$index");require("module$node_modules$jsontokens$lib$decode");var _errors=require("module$node_modules$jsontokens$lib$errors");exports.TokenSigner=function(){function TokenSigner(signingAlgorithm,rawPrivateKey){if(!(this instanceof TokenSigner))throw new TypeError("Cannot call a class as a function");
if(!signingAlgorithm||!rawPrivateKey)throw new _errors.MissingParametersError("a signing algorithm and private key are required");if("string"!==typeof signingAlgorithm)throw"signing algorithm parameter must be a string";signingAlgorithm=signingAlgorithm.toUpperCase();if(!_cryptoClients.cryptoClients.hasOwnProperty(signingAlgorithm))throw"invalid signing algorithm";this.tokenType="JWT";this.cryptoClient=_cryptoClients.cryptoClients[signingAlgorithm];this.rawPrivateKey=rawPrivateKey}_createClass(TokenSigner,
[{key:"header",value:function(){return{typ:this.tokenType,alg:this.cryptoClient.algorithmName}}},{key:"sign",value:function(payload){var expanded=1<arguments.length&&void 0!==arguments[1]?arguments[1]:!1,signingInput=createSigningInput(payload,this.header()),signingInputHash=this.cryptoClient.createHash(signingInput);signingInputHash=this.cryptoClient.signHash(signingInputHash,this.rawPrivateKey);return expanded?{header:[_base64url2.default.encode(JSON.stringify(this.header()))],payload:JSON.stringify(payload),
signature:[signingInputHash]}:[signingInput,signingInputHash].join(".")}}]);return TokenSigner}()}
//# sourceMappingURL=module$node_modules$jsontokens$lib$signer.js.map
