shadow$provide.module$node_modules$blockstack$lib$operations$signers=function(global,process,require,module,exports,shadow$shims){Object.defineProperty(exports,"__esModule",{value:!0});exports.PubkeyHashSigner=void 0;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;"value"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,
descriptor)}}return function(Constructor,protoProps,staticProps){protoProps&&defineProperties(Constructor.prototype,protoProps);staticProps&&defineProperties(Constructor,staticProps);return Constructor}}();require("module$node_modules$bitcoinjs_lib$src$index");var _utils=require("module$node_modules$blockstack$lib$utils");exports.PubkeyHashSigner=function(){function PubkeyHashSigner(ecPair){if(!(this instanceof PubkeyHashSigner))throw new TypeError("Cannot call a class as a function");this.ecPair=
ecPair}_createClass(PubkeyHashSigner,[{key:"signerVersion",value:function(){return 1}},{key:"getAddress",value:function(){var _this=this;return Promise.resolve().then(function(){return(0,_utils.ecPairToAddress)(_this.ecPair)})}},{key:"signTransaction",value:function(transaction,inputIndex){var _this2=this;return Promise.resolve().then(function(){transaction.sign(inputIndex,_this2.ecPair)})}}],[{key:"fromHexString",value:function(keyHex){return new PubkeyHashSigner((0,_utils.hexStringToECPair)(keyHex))}}]);
return PubkeyHashSigner}()}
//# sourceMappingURL=module$node_modules$blockstack$lib$operations$signers.js.map
