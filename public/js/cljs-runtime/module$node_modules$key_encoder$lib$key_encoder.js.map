{
"version":3,
"file":"module$node_modules$key_encoder$lib$key_encoder.js",
"lineCount":8,
"mappings":"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",
"sources":["node_modules/key-encoder/lib/key-encoder.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$key_encoder$lib$key_encoder\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict'\n\nvar asn1 = require('asn1.js'),\n    BN = require('bn.js'),\n    EC = require('elliptic').ec\n\nvar ECPrivateKeyASN = asn1.define('ECPrivateKey', function() {\n    this.seq().obj(\n        this.key('version').int(),\n        this.key('privateKey').octstr(),\n        this.key('parameters').explicit(0).objid().optional(),\n        this.key('publicKey').explicit(1).bitstr().optional()\n    )\n})\n\nvar SubjectPublicKeyInfoASN = asn1.define('SubjectPublicKeyInfo', function() {\n    this.seq().obj(\n        this.key('algorithm').seq().obj(\n            this.key(\"id\").objid(),\n            this.key(\"curve\").objid()\n        ),\n        this.key('pub').bitstr()\n    )\n})\n\nvar curves = {\n    secp256k1: {\n        curveParameters: [1, 3, 132, 0, 10],\n        privatePEMOptions: {label: 'EC PRIVATE KEY'},\n        publicPEMOptions: {label: 'PUBLIC KEY'},\n        curve: new EC('secp256k1')\n    }\n}\n\nfunction assert(val, msg) {\n    if (!val) {\n        throw new Error(msg || 'Assertion failed')\n    }\n}\n\nfunction KeyEncoder(options) {\n    if (typeof options === 'string') {\n        assert(curves.hasOwnProperty(options), 'Unknown curve ' + options)\n        options = curves[options]\n    }\n    this.options = options\n    this.algorithmID = [1, 2, 840, 10045, 2, 1]\n}\n\nKeyEncoder.ECPrivateKeyASN = ECPrivateKeyASN\nKeyEncoder.SubjectPublicKeyInfoASN = SubjectPublicKeyInfoASN\n\nKeyEncoder.prototype.privateKeyObject = function(rawPrivateKey, rawPublicKey) {\n    var privateKeyObject = {\n        version: new BN(1),\n        privateKey: new Buffer(rawPrivateKey, 'hex'),\n        parameters: this.options.curveParameters\n    }\n\n    if (rawPublicKey) {\n        privateKeyObject.publicKey = {\n            unused: 0,\n            data: new Buffer(rawPublicKey, 'hex')\n        }\n    }\n\n    return privateKeyObject\n}\n\nKeyEncoder.prototype.publicKeyObject = function(rawPublicKey) {\n    return {\n        algorithm: {\n            id: this.algorithmID,\n            curve: this.options.curveParameters\n        },\n        pub: {\n            unused: 0,\n            data: new Buffer(rawPublicKey, 'hex')\n        }\n    }\n}\n\nKeyEncoder.prototype.encodePrivate = function(privateKey, originalFormat, destinationFormat) {\n    var privateKeyObject\n\n    /* Parse the incoming private key and convert it to a private key object */\n    if (originalFormat === 'raw') {\n        if (!typeof privateKey === 'string') {\n            throw 'private key must be a string'\n        }\n        var privateKeyObject = this.options.curve.keyFromPrivate(privateKey, 'hex'),\n            rawPublicKey = privateKeyObject.getPublic('hex')\n        privateKeyObject = this.privateKeyObject(privateKey, rawPublicKey)\n    } else if (originalFormat === 'der') {\n        if (typeof privateKey === 'buffer') {\n            // do nothing\n        } else if (typeof privateKey === 'string') {\n            privateKey = new Buffer(privateKey, 'hex')\n        } else {\n            throw 'private key must be a buffer or a string'\n        }\n        privateKeyObject = ECPrivateKeyASN.decode(privateKey, 'der')\n    } else if (originalFormat === 'pem') {\n        if (!typeof privateKey === 'string') {\n            throw 'private key must be a string'\n        }\n        privateKeyObject = ECPrivateKeyASN.decode(privateKey, 'pem', this.options.privatePEMOptions)\n    } else {\n        throw 'invalid private key format'\n    }\n\n    /* Export the private key object to the desired format */\n    if (destinationFormat === 'raw') {\n        return privateKeyObject.privateKey.toString('hex')\n    } else if (destinationFormat === 'der') {\n        return ECPrivateKeyASN.encode(privateKeyObject, 'der').toString('hex')\n    } else if (destinationFormat === 'pem') {\n        return ECPrivateKeyASN.encode(privateKeyObject, 'pem', this.options.privatePEMOptions)\n    } else {\n        throw 'invalid destination format for private key'\n    }\n}\n\nKeyEncoder.prototype.encodePublic = function(publicKey, originalFormat, destinationFormat) {\n    var publicKeyObject\n\n    /* Parse the incoming public key and convert it to a public key object */\n    if (originalFormat === 'raw') {\n        if (!typeof publicKey === 'string') {\n            throw 'public key must be a string'\n        }\n        publicKeyObject = this.publicKeyObject(publicKey)\n    } else if (originalFormat === 'der') {\n        if (typeof publicKey === 'buffer') {\n            // do nothing\n        } else if (typeof publicKey === 'string') {\n            publicKey = new Buffer(publicKey, 'hex')\n        } else {\n            throw 'public key must be a buffer or a string'\n        }\n        publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, 'der')\n    } else if (originalFormat === 'pem') {\n        if (!typeof publicKey === 'string') {\n            throw 'public key must be a string'\n        }\n        publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, 'pem', this.options.publicPEMOptions)\n    } else {\n        throw 'invalid public key format'\n    }\n\n    /* Export the private key object to the desired format */\n    if (destinationFormat === 'raw') {\n        return publicKeyObject.pub.data.toString('hex')\n    } else if (destinationFormat === 'der') {\n        return SubjectPublicKeyInfoASN.encode(publicKeyObject, 'der').toString('hex')\n    } else if (destinationFormat === 'pem') {\n        return SubjectPublicKeyInfoASN.encode(publicKeyObject, 'pem', this.options.publicPEMOptions)\n    } else {\n        throw 'invalid destination format for public key'\n    }\n}\n\nmodule.exports = KeyEncoder\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","KeyEncoder","options","curves","hasOwnProperty","val","Error","algorithmID","asn1","BN","EC","ec","ECPrivateKeyASN","define","seq","obj","key","int","octstr","explicit","objid","optional","bitstr","SubjectPublicKeyInfoASN","secp256k1","curveParameters","privatePEMOptions","label","publicPEMOptions","curve","prototype","privateKeyObject","KeyEncoder.prototype.privateKeyObject","rawPrivateKey","rawPublicKey","version","privateKey","Buffer","parameters","publicKey","unused","data","publicKeyObject","KeyEncoder.prototype.publicKeyObject","algorithm","id","pub","encodePrivate","KeyEncoder.prototype.encodePrivate","originalFormat","destinationFormat","keyFromPrivate","getPublic","decode","toString","encode","encodePublic","KeyEncoder.prototype.encodePublic"]
}
