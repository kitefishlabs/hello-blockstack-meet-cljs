shadow$provide.module$node_modules$triplesec$lib$algbase=function(global,process,require,module,exports,shadow$shims){(function(){var BlockCipher,__hasProp={}.hasOwnProperty,__extends=function(child,parent){function ctor(){this.constructor=child}for(var key in parent)__hasProp.call(parent,key)&&(child[key]=parent[key]);ctor.prototype=parent.prototype;child.prototype=new ctor;child.__super__=parent.prototype;return child};var WordArray=require("module$node_modules$triplesec$lib$wordarray").WordArray;
var util=require("module$node_modules$triplesec$lib$util");var BufferedBlockAlgorithm=function(){function BufferedBlockAlgorithm(){this.reset()}BufferedBlockAlgorithm.prototype._minBufferSize=0;BufferedBlockAlgorithm.prototype.reset=function(){this._data=new WordArray;return this._nDataBytes=0};BufferedBlockAlgorithm.prototype._append=function(data){this._data.concat(data);return this._nDataBytes+=data.sigBytes};BufferedBlockAlgorithm.prototype._process=function(doFlush){var _ref;var data=this._data;
var dataWords=data.words;var dataSigBytes=data.sigBytes;var nBlocksReady=dataSigBytes/(4*this.blockSize);nBlocksReady=doFlush?Math.ceil(nBlocksReady):Math.max((nBlocksReady|0)-this._minBufferSize,0);doFlush=nBlocksReady*this.blockSize;dataSigBytes=Math.min(4*doFlush,dataSigBytes);if(doFlush){var offset=nBlocksReady=0;for(_ref=this.blockSize;0<_ref?nBlocksReady<doFlush:nBlocksReady>doFlush;offset=nBlocksReady+=_ref)this._doProcessBlock(dataWords,offset);offset=dataWords.splice(0,doFlush);data.sigBytes-=
dataSigBytes}return new WordArray(offset,dataSigBytes)};BufferedBlockAlgorithm.prototype.copy_to=function(out){out._data=this._data.clone();return out._nDataBytes=this._nDataBytes};BufferedBlockAlgorithm.prototype.clone=function(){var obj=new BufferedBlockAlgorithm;this.copy_to(obj);return obj};return BufferedBlockAlgorithm}();var Hasher=function(_super){function Hasher(){Hasher.__super__.constructor.call(this)}__extends(Hasher,_super);Hasher.prototype.reset=function(){Hasher.__super__.reset.call(this);
this._doReset();return this};Hasher.prototype.update=function(messageUpdate){this._append(messageUpdate);this._process();return this};Hasher.prototype.finalize=function(messageUpdate){messageUpdate&&this._append(messageUpdate);return this._doFinalize()};Hasher.prototype.bufhash=function(input){var wa_in=WordArray.from_buffer(input);var wa_out=this.finalize(wa_in);input=wa_out.to_buffer();wa_in.scrub();wa_out.scrub();return input};return Hasher}(BufferedBlockAlgorithm);exports.BlockCipher=BlockCipher=
function(){function BlockCipher(key){}BlockCipher.prototype.encryptBlock=function(M,offset){};return BlockCipher}();var StreamCipher$jscomp$0=function(){function StreamCipher(){}StreamCipher.prototype.encryptBlock=function(word_array,dst_offset){null==dst_offset&&(dst_offset=0);var pad=this.get_pad();word_array.xor(pad,{dst_offset:dst_offset,n_words:Math.min(word_array.words.length-dst_offset,this.bsiw)});pad.scrub();return this.bsiw};StreamCipher.prototype.encrypt=function(word_array){var _i,_ref1;
var i=_i=0;var _ref=word_array.words.length;for(_ref1=this.bsiw;0<_ref1?_i<_ref:_i>_ref;i=_i+=_ref1)this.encryptBlock(word_array,i);return word_array};StreamCipher.prototype.bulk_encrypt=function(_arg,cb){var input=_arg.input;var progress_hook=_arg.progress_hook;var what=_arg.what;_arg={update:function(_this){return function(lo,hi){var _i,_ref;var _results=[];lo=_i=lo;for(_ref=_this.bsiw;0<_ref?_i<hi:_i>hi;lo=_i+=_ref)_results.push(_this.encryptBlock(input,lo));return _results}}(this),finalize:function(){return input},
default_n:1024*this.bsiw};return util.bulk(input.sigBytes,_arg,{progress_hook:progress_hook,cb:cb,what:what})};return StreamCipher}();exports.BlockCipher=BlockCipher;exports.Hasher=Hasher;exports.BufferedBlockAlgorithm=BufferedBlockAlgorithm;exports.StreamCipher=StreamCipher$jscomp$0}).call(this)}
//# sourceMappingURL=module$node_modules$triplesec$lib$algbase.js.map
