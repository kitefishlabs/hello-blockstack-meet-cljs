shadow$provide.module$node_modules$elliptic$lib$elliptic$eddsa$index=function(global,process,require,module,exports,shadow$shims){function EDDSA(curve){assert("ed25519"===curve,"only tested with ed25519 so far");if(!(this instanceof EDDSA))return new EDDSA(curve);this.curve=curve=elliptic.curves[curve].curve;this.g=curve.g;this.g.precompute(curve.n.bitLength()+1);this.pointClass=curve.point().constructor;this.encodingLength=Math.ceil(curve.n.bitLength()/8);this.hash=hash$jscomp$0.sha512}var hash$jscomp$0=
require("module$node_modules$hash_DOT_js$lib$hash"),elliptic=require("module$node_modules$elliptic$lib$elliptic"),utils=elliptic.utils,assert=utils.assert,parseBytes=utils.parseBytes,KeyPair=require("module$node_modules$elliptic$lib$elliptic$eddsa$key"),Signature=require("module$node_modules$elliptic$lib$elliptic$eddsa$signature");module.exports=EDDSA;EDDSA.prototype.sign=function(message,secret){message=parseBytes(message);var key=this.keyFromSecret(secret),r=this.hashInt(key.messagePrefix(),message);
secret=this.g.mul(r);var Rencoded=this.encodePoint(secret);message=this.hashInt(Rencoded,key.pubBytes(),message).mul(key.priv());message=r.add(message).umod(this.curve.n);return this.makeSignature({R:secret,S:message,Rencoded:Rencoded})};EDDSA.prototype.verify=function(message,sig,pub){message=parseBytes(message);sig=this.makeSignature(sig);pub=this.keyFromPublic(pub);message=this.hashInt(sig.Rencoded(),pub.pubBytes(),message);var SG=this.g.mul(sig.S());return sig.R().add(pub.pub().mul(message)).eq(SG)};
EDDSA.prototype.hashInt=function(){for(var hash=this.hash(),i=0;i<arguments.length;i++)hash.update(arguments[i]);return utils.intFromLE(hash.digest()).umod(this.curve.n)};EDDSA.prototype.keyFromPublic=function(pub){return KeyPair.fromPublic(this,pub)};EDDSA.prototype.keyFromSecret=function(secret){return KeyPair.fromSecret(this,secret)};EDDSA.prototype.makeSignature=function(sig){return sig instanceof Signature?sig:new Signature(this,sig)};EDDSA.prototype.encodePoint=function(point){var enc=point.getY().toArray("le",
this.encodingLength);enc[this.encodingLength-1]|=point.getX().isOdd()?128:0;return enc};EDDSA.prototype.decodePoint=function(bytes){bytes=utils.parseBytes(bytes);var lastIx=bytes.length-1,normed=bytes.slice(0,lastIx).concat(bytes[lastIx]&-129);bytes=0!==(bytes[lastIx]&128);normed=utils.intFromLE(normed);return this.curve.pointFromY(normed,bytes)};EDDSA.prototype.encodeInt=function(num){return num.toArray("le",this.encodingLength)};EDDSA.prototype.decodeInt=function(bytes){return utils.intFromLE(bytes)};
EDDSA.prototype.isPoint=function(val){return val instanceof this.pointClass}}
//# sourceMappingURL=module$node_modules$elliptic$lib$elliptic$eddsa$index.js.map
