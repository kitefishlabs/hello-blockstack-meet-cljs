shadow$provide.module$node_modules$public_encrypt$privateDecrypt=function(global,process,require,module,exports,shadow$shims){var parseKeys=require("module$node_modules$parse_asn1$index"),mgf=require("module$node_modules$public_encrypt$mgf"),xor=require("module$node_modules$public_encrypt$xor"),BN=require("module$node_modules$bn_DOT_js$lib$bn"),crt=require("module$node_modules$browserify_rsa$index"),createHash=require("module$node_modules$create_hash$browser"),withPublic=require("module$node_modules$public_encrypt$withPublic"),
Buffer=require("module$node_modules$safe_buffer$index").Buffer;module.exports=function(privateKey,enc,reverse){var padding=privateKey.padding?privateKey.padding:reverse?1:4;privateKey=parseKeys(privateKey);var k=privateKey.modulus.byteLength();if(enc.length>k||0<=(new BN(enc)).cmp(privateKey.modulus))throw Error("decryption error");enc=reverse?withPublic(new BN(enc),privateKey):crt(enc,privateKey);var zBuffer=Buffer.alloc(k-enc.length);enc=Buffer.concat([zBuffer,enc],k);if(4===padding){k=enc;padding=
privateKey.modulus.byteLength();privateKey=createHash("sha1").update(Buffer.alloc(0)).digest();reverse=privateKey.length;if(0!==k[0])throw Error("decryption error");enc=k.slice(1,reverse+1);k=k.slice(reverse+1);enc=xor(enc,mgf(k,reverse));padding=xor(k,mgf(enc,padding-reverse-1));k=padding.slice(0,reverse);privateKey=Buffer.from(privateKey);k=Buffer.from(k);enc=0;zBuffer=privateKey.length;privateKey.length!==k.length&&(enc++,zBuffer=Math.min(privateKey.length,k.length));for(var i=-1;++i<zBuffer;)enc+=
privateKey[i]^k[i];if(enc)throw Error("decryption error");for(;0===padding[reverse];)reverse++;if(1!==padding[reverse++])throw Error("decryption error");return padding.slice(reverse)}if(1===padding){padding=enc;privateKey=padding.slice(0,2);k=2;for(enc=0;0!==padding[k++];)if(k>=padding.length){enc++;break}zBuffer=padding.slice(2,k-1);("0002"!==privateKey.toString("hex")&&!reverse||"0001"!==privateKey.toString("hex")&&reverse)&&enc++;8>zBuffer.length&&enc++;if(enc)throw Error("decryption error");return padding.slice(k)}if(3===
padding)return enc;throw Error("unknown padding");}}
//# sourceMappingURL=module$node_modules$public_encrypt$privateDecrypt.js.map
